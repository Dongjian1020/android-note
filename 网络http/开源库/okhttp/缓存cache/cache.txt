参见：
OkHttp3源码分析[缓存策略]
	http://www.jianshu.com/p/9cebbbd0eeab
OKHttp源码解析(六)--中阶之缓存基础 - 简书
	http://www.jianshu.com/p/b32d13655be7

获得request的candidate cache：
okhttp3.Cache#get
	得到key: okhttp3.Cache#key
		ByteString.encodeUtf8(httpUrl.toString()).md5().hex();
	okhttp3.internal.cache.DiskLruCache#get

CacheControl对应着 header中的cache-control
如何构建：CacheControl#parse(Headers headers)

CacheInterceptor#intercept
	得到cacheCandidate（来自：okhttp3.Cache#get(Request)，即是：先不管用不用该缓存，先提供给我缓存），
	得到CacheStrategy：
		CacheStrategy.Factory#get
			CacheStrategy.Factory#getCandidate
				得到CacheStrategy
					核心数据：
					是否需要发送联网请求
						CacheStrategy#networkRequest
					缓存的内容					
						CacheStrategy#cacheResponse
			如果request要求onlyIfCache（只从缓存中读取数据） 且 得到的CacheStrategy又要求访问网络，则返回 CacheStrategy(null,null)
	根据CacheStrategy#networkRequest和CacheStrategy#cacheResponse来决定：是否只读取缓存，是否联网请求 等
	如果要进行联网请求，在响应获得后，
		如果是缓存未发生变化（304：HttpURLConnection#HTTP_NOT_MODIFIED），则更新缓存（Cache#update）
		否则，将响应放入到缓存中
			okhttp3.Cache#put
				其中，DiskLruCache.Entry.key为：ByteString.encodeUtf8(HttpUrl.toString()).md5().hex()
					参见：okhttp3.Cache#key
			CacheInterceptor#cacheWritingResponse				

--------------------------------问题：
如何判断 结果来自缓存 还是 来自网络
为什么会有该问题：
当CacheInterceptor将缓存中的结果返回时，方式为：即是：设置了Response.cacheResponse为null
	return cacheResponse.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build();
