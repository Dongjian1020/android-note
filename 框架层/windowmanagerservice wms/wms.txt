参见：
Android应用Activity、Dialog、PopWindow、Toast窗口添加机制及源码分析 - CSDN博客
	http://blog.csdn.net/yanbober/article/details/46361191
Android应用程序窗口（Activity）实现框架简要介绍和学习计划 （等系列教程）
	http://blog.csdn.net/luoshengyang/article/details/8170307
	系列教程入口：http://blog.csdn.net/Luoshengyang/article/list/3
Android窗口机制（一）初识Android的窗口结构
	http://www.jianshu.com/p/40a9c93b5a8d
	拥有系列教程，其为第一篇
深入理解Activity——Token之旅
	http://blog.csdn.net/guoqifa29/article/details/46819377

WindowManager - IWindowManager的确定：
WindowManager
WindowManagerImpl
	WindowManagerGlobal（单例）
		IWindowManager.Stub.asInterface(ServiceManager.getService("window"))
		
Activity和WindowManager的关联：
在Activity#attach中
	构建了Window
	也构建了WindowManager：WindowManagerImpl#createLocalWindowManager
		其parentWindow为 activity的创建的那个window

Window和parentWindow的关系的确定：
有什么用：
	dialog中的window 依附于 activity.window
每个Window都和WindowManager关联
	通过Window#setWindowManager
而WindowManager是依附于parentWindow的
则可确定 Window 和 parentWindow的关系（有可能parentWindow就是其自身）

Window的重要属性：
view
wlp	
	
窗口类型（3种，WindowManager.LayoutParams.type）
ApplicationWindows
	取值在FIRST_APPLICATION_WINDOW与LAST_APPLICATION_WINDOW之间，是常用的顶层应用程序窗口，须将token设置成Activity的token；
SubWindows
	取值在FIRST_SUB_WINDOW和LAST_SUB_WINDOW之间，与顶层窗口相关联，需将token设置成它所附着宿主窗口的token；
SystemWindows
	取值在FIRST_SYSTEM_WINDOW和LAST_SYSTEM_WINDOW之间，不能用于应用程序，使用时需要有特殊权限，它是特定的系统功能才能使用；
	
Window和appToken关联
如果WindowManager.LayoutParams的type是：LayoutParams#TYPE_APPLICATION，那么该window就需要和一个appToken关联
该appToken对应一个activity（由ActivityClientRecord.token表示）



共享内存
管道是单向的吗？只能一个地方写？
>>>touch, key事件的分发
注册管道
	viewrootimpl.setview中
		mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
	        getHostVisibility(), mDisplay.getDisplayId(),
	        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
	        mAttachInfo.mOutsets, mInputChannel);
	    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); 
当有事件时
	ViewRootImpl.WindowInputEventReceiver#onInputEvent
		enqueueInputEvent
			doProcessInputEvents
				deliverInputEvent
注册一个inputchannle
wms将会产生一个管道，
两个管道，
	前向管道 和 反向管道
	server往前向管道中写，client从反向管道中读
	client从前向管道中读，client往反向管道中写
收到事件后（按键事件，或者，touch事件），让server往前向管道中来写

该channel

当产生事件后，wms将该事件 分发到inputchannel中，而viewroot注册了该channel的另外一端 （具体怎么注册~！！！！！！！！！！，老罗的文章）
则viewroot收到该事件(通过：ViewRootImpl#dispatchInputEvent(InputEvent))
后->decorview->activity(实现window.callback)
