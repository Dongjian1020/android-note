参见：
Android应用程序启动过程源代码分析
	http://blog.csdn.net/luoshengyang/article/details/6689748

------------------------------AMS进程
ActivityManagerService（I接口：IActivityManager，继承自：ActivityManagerNative（本质：I接口.stub））
	负责：启动进程，启动/管理 Activity和Service
ApplicationThreadProxy（I接口：IApplicationThread）
	ams进程 使用iapplicationthread 来和 app进程 交互
	如何获得：
		在启动app进程时（通过执行Process.start("android.app.ActivityThread",xxx)，进而执行activitythread.main），执行activitythread.attch，其中调用iactivitymanager.attachapplication()时，将app的applicationthread作为参数传入
			而最终activitymanagerservice会将 pid（IBinder.getCallingPid()）和该iapplicationthread进行关联（processrecord.id 与 processrecord.thread）
		或，app通过iactivitymanager.mRemote.transact中，applicationthread被传入：data.writeStrongBinder(caller != null ? caller.asBinder() : null);
			这里的call就是applicationthread
ActityStack
	产生ActivityRecord
	为activity分配task
	启动activity
--
ProcessRecord
	其代表着进程
	其pid属性 为新创建的进程的pid（通过执行）
	其thread属性 为iapplicationthread类型，对应 app的ApplicationThread
	uid属性
	processName属性
TaskRecord
	代表task
ActivityRecord
	代表着activity
	其拥有：Token（继承自IApplicationToken.Stub）
		数据结构：WeakReference<ActivityRecord> weakActivity 和 ActivityManagerService mService
		该token会传入到 app进程中，来告诉，当前要针对于哪个activity进行处理
	其持有：taskrecord, processrecord

------------------------------app进程
ActivityThread
	app进程被启动时，执行的是：ActivityThread.main方法（该方法执行时的 所在线程 为主线程）
	ams进程 和 本app进程 进行交互时（通过iapplicationthread）（要处理 框架级别的消息）
		流程为：applicationthread.scheduleXXX -> 向handler H发送消息（其对应的looper在main()中被创建）-> activityhandler.handleXXX
	--
	如何获得：执行activitythread.main时创建
ActivityManagerProxy（I接口：IActivityManager）
	作用：app进程 通过其 与ams进程 交互（如：IActivityManager#attachApplication(IApplicationThread app)来让 ams知道ApplicationThread）
	--
	如何获得：ActivityManagerNative.getDefault()
ApplicationThread（I接口：IApplicationThread，继承自ApplicationThreadNative（本质：I接口.stub））
	作用：ams进程 通过其 来与app进程 进行交互
	--
	如何获得：activitythread的成员变量
--
Instrumentation
	监控Activity/application的 创建等，相当于是系统运行日志。
ActivityClientRecord
	对应着 ams进程的 ActivityRecord

------------------------------app进程 与 ams进程 的交互示例
背景：当前界面为appA的activityA，现在要启动 appB的activityB
在appA中，通过iactivitymanager，向ams发请求：要求启动 appB的activityB
ams通过iapplicationthread 要求activityA 进行pause
appA的applicationthread收到请求后，要求activitythread来 pause activityA
activityA被pause后，通过iactivitymanager 向ams汇报
ams要启动activityB，首先判断activityB对应的processrecord是否存在（通过processname（activityrecord.processname）, uid（activityrecord.activityinfo.applicationinfo.uid）的方式），并没有发现 该processrecord
创建processrecord对象（存入关键信息（processName,uid等）），创建进程
appB的activitythread.main执行，并执行了activitythread.attach，汇报自己的applicationthread
ams收到该iapplicationthread，并将pid（通过ibinder.getcallingpid）和该iapplicationthread存入到processrecord中
ams发现 之前要启动的activityrecord（对应activityB） 的app（processrecord）为空（因为为空，才创建进程的么），但是刚被attach的processrecord的 name和uid 均满足activityrecord的要求，那么，启动该activityrecord
ams通过 appB的iapplicationthread，要求 启动activityB
appB的applicationthread 要求 activitythread 启动activityB
	创建activityB对象
	创建application对象（如果需要）
	activityB.attach
	执行activityB的oncreate
	执行activityB.onRestoreInstanceState
