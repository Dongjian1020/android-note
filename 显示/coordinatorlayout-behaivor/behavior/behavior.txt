参见：
http://www.jianshu.com/p/a506ee4afecb
https://segmentfault.com/a/1190000002888109
https://developer.android.com/intl/zh-cn/reference/android/support/design/widget/CoordinatorLayout.Behavior.html
--
http://saulmm.github.io/mastering-coordinator

behaivor原理：
当view1进行了某些transform，parent能被通知，后进而委派给behaivor，后通知view2 来进行一些响应（如，也进行某些transform）
这样，view1和view2就能进行互动了
此种情况下，view1是dependency，view2是child（behaivor的执行者），它们都是coordinatorlayout的直接孩子
什么优点：虽然view2根据view1的transform而transform，但是在它们自身的ontouch中 却不需要改动。协调逻辑是放在behaivor中进行的

coordinatorlayout
CoordinatorLayout所做的事情就是当成一个通信的桥梁，连接不同的view。使用Behavior对象进行通信。
可认为是一个framelayout

view1和view2都必须是coordinatorlayout的孩子

view1和view2如何确定关系：
在layout.xml中
	的view2，app:layout_behavior=“你的Behavior的完全限定类名”
在behaivor中
	确定:view2依赖于view1
		@Override
		public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
			return dependency.getId() == R.id.first;
		}
	确定:view2 根据view1的transform 要进行怎样的transform
		onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) 
	--
	其中，T是View的子类

parent能被通知的情况：
dependency发生了transform (coordinatorlayout的layout发生了改变)
dependency发生了scroll
	需要dependency实现NestedScrollingChild接口，而parent（此处为coordinatorlayout）需要实现NestedScrollingParent接口
	coordinatorlayout将根据nestedscrolling规则，被调用nestedscrolling相关的回调
	而，在这些回调方法中，将会委派给behaivor的相应方法。则，此刻behaivor内部至少需要实现如下方法
		@Override
		public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) {
			return true;//这里返回true，才会接受到后续滑动事件。
		}

		@Override
		public void onNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) {
			//进行滑动事件处理
		}

		@Override
		public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY, boolean consumed) {
			//当进行快速滑动
			return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed);
		}
