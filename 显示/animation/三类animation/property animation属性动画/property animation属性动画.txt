参见：
Android属性动画详解(一)，属性动画基本用法
	http://gold.xitu.io/post/579f0277d342d300572033b1
http://developer.android.com/guide/topics/graphics/prop-animation.html
http://blog.csdn.net/tu_bingbing/article/details/8917992

相较于之前view animation的优点
将view移动到一个位置，而后对其新位置进行点击，view能响应
	view animation system is that it only modified where the View was drawn, and not the actual View itself
	The view animation system transformed View objects by changing the way that they were drawn. T
	his was handled in the container of each View, because the View itself had no properties to manipulate. 
	This resulted in the View being animated, but caused no change in the View object itself. 
		This led to behavior such as an object still existing in its original location, even though it was drawn on a different location on the screen. 
	为此，属性动画新增了一些属性
		translationX and translationY: 
			These properties control where the View is located as a delta from its left and top coordinates which are set by its layout container.
		rotation, rotationX, and rotationY: 
			These properties control the rotation in 2D (rotation property) and 3D around the pivot point.
		scaleX and scaleY: 
			These properties control the 2D scaling of a View around its pivot point.
		pivotX and pivotY: 
			These properties control the location of the pivot point, around which the rotation and scaling transforms occur. By default, the pivot point is located at the center of the object.
		x and y: 
			These are simple utility properties to describe the final location of the View in its container, 
			x=left+translationx
			y=top+translationy
alpha: Represents the alpha transparency on the View. This value is 1 (opaque) by default, with a value of 0 representing full transparency (not visible).
属性动画可以对任何对象的属性进行动画（而不仅仅是view的）

----------------------------------------------------

------------valueanimator
其不作用于任何对象，仅仅是作用于一个值
我们可以监听（通过animatorupdatelistener）该值的 变化比例（通过animator.getanimatedfraction） ，再依据该变化比例 来完成其他事情

------------ObjectAnimator
ObjectAnimator
作用于myObj.属性x
	有哪些属性可选：https://developer.android.com/guide/topics/graphics/prop-animation.html#views
用法：ObjectAnimator.ofFloat(myObj, 属性x, 目标值).setXXX().start()
	其中，属性x可以使用 字符串的形式，
	也可以使用Property<T, float的形式>，如
		public static final Property<View, Float> SCALE_X = new FloatProperty<View>("scaleX") {
			@Override
			public void setValue(View object, float value) {
				object.setScaleX(value);
			}

			@Override
			public Float get(View object) {
				return object.getScaleX();
			}
		};
原理：
	根据frame刷新率，通过 myObj的set/get方法 来
		set用于设置新值
		get用于获得原始值

------------动画集合
animator的集合，每个animator均可以作用于一个具体的对象
animatorset.playTogether(
	objectAnimator1,
	objectAnimator1,
	,,,).start()
几类play方式
	playSequentially()：多个动画按顺序执行
	playTogether()：几个动画同时执行
获得其中的一个animator：animtorset.getChildAnimations().get(i)
例子：
	AnimatorSet bouncer = new AnimatorSet();
	bouncer.play(bounceAnim).before(squashAnim1);
	bouncer.play(squashAnim1).with(squashAnim2);
	bouncer.play(squashAnim1).with(stretchAnim1);
	bouncer.play(squashAnim1).with(stretchAnim2);
	bouncer.play(bounceBackAnim).after(stretchAnim2);
	ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);
	fadeAnim.setDuration(250);
	AnimatorSet animatorSet = new AnimatorSet();
	animatorSet.play(bouncer).before(fadeAnim);
	animatorSet.start();
效果:
	1.Plays bounceAnim.
	2.Plays squashAnim1, squashAnim2, stretchAnim1, and stretchAnim2 at the same time.
	3.Plays bounceBackAnim.
	4.Plays fadeAnim.
----
例子：
	ObjectAnimator animX = ObjectAnimator.ofFloat(myView, "x", 50f);
	ObjectAnimator animY = ObjectAnimator.ofFloat(myView, "y", 100f);
	AnimatorSet animSetXY = new AnimatorSet();
	animSetXY.playTogether(animX, animY);
	animSetXY.start();

如果动画集中的每个动画都针对于同一个对象，可以使用如下：
PropertyValuesHolder
	PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat("x", 50f);
	PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat("y", 100f);
	ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();
ViewPropertyAnimator
	myView.animate().x(50f).y(100f);

------------animatorupdatelistener	
	监听 整个动画播放过程
	onAnimationUpdate() 
		根据frame刷新率（如：10ms/帧），就会被调用一次

------------animatorlistener
	监听 开始，结束，取消，重复
	一个实现子类（包含了空的方法体）：AnimatorListenerAdapter

keyframe
A Keyframe object consists of a time/value pair that lets you define a specific state at a specific time of an animation. 
Each keyframe can also have its own interpolator to control the behavior of the animation in the interval between the previous keyframe's time and the time of this keyframe.
例子：
	Keyframe kf0 = Keyframe.ofFloat(0f, 0f);
	Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);
	Keyframe kf2 = Keyframe.ofFloat(1f, 0f);
	PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe("rotation", kf0, kf1, kf2);
	ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)
	rotationAnim.setDuration(5000ms);

----------------------------------------------------

动画默认持续时间：300ms
frame刷新率：10ms/帧

开始，暂停，继续，停止
start,
pause,
resume,
end
	一旦停止，会立刻到达终点状态
	
rotate
当要进行旋转时，效果上，遵循的是 左手定理
