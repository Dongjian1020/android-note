<html>
<head>
<title> Overview of the JNI Design</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="part3.html">Prev</a> | <a href="types.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<hr><br>
 
<div align="right">
<h1 align="left">
  <a name="8147"> </a><font color="#663300" face="Arial, Verdana, Helvetica, sans-serif">Chapter 11 chapter</font>
</h1>
</div>
<a name="8148"></a>
<h1>Overview of the JNI Design</h1>
<hr><p>

<p>
  <a name="8149"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="7" face="Arial, Verdana, Helvetica, sans-serif">T</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">his</font> chapter gives an overview of the JNI design. Where necessary, we also provide the underlying technical motivation. The design overview serves as the specification for key JNI concepts such as the <code>JNIEnv</code> interface pointer, local and global references, and field and method IDs. The technical motivation aims at helping the reader to understand various design trade-offs. On a few occasions, we will discuss how certain features may be implemented. The purpose of such discussion is not to present a practical implementation strategy, but instead to clarify the subtle semantic issues.</font>
</p>


<p>
  <a name="8132"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The concept of a programming interface that bridges different languages is not new. For example, C programs can typically call functions written in languages such as FORTRAN and assembly. Similarly, implementations of programming languages such as LISP and Smalltalk support a variety of foreign function interfaces. </font>
</p>


<p>
  <a name="7957"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI addresses an issue similar to that addressed by the interoperability mechanisms supported by other languages. There is, however, a significant difference between the JNI and the interoperability mechanisms used in many other languages. The JNI is not designed for a particular implementation of the Java virtual machine. Rather, it is a native interface that can be supported by every implementation of the Java virtual machine. We will further elaborate on this as we describe the JNI design goals.</font>
</p>

<a name="2333"></a>
<h2>11.1    Design Goals</h2>

<p>
  <a name="7975"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The most important goal of the JNI design is ensuring that it offers <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">binary compatibility</font> among different Java virtual machine implementations on a given host environment. The same native library binary will run on different virtual machine implementations on a given host environment without the need for recompilation.</font>
</p>


<p>
  <a name="7980"> </a><font face="Arial, Verdana, Helvetica, sans-serif">To achieve this goal, the JNI design cannot make any assumptions about the internal details of the Java virtual machine implementation. Because Java virtual machine implementation technologies are evolving rapidly, we must be careful to avoid introducing any constraints that may interfere with advanced implementation techniques in the future.</font>
</p>


<p>
  <a name="2310"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The second goal of JNI design is <em>efficiency</em>. To support time-critical code, the JNI imposes as little overhead as possible. We will see, however, that our first goal, the need for implementation-independence, sometimes requires us to adopt a slightly less efficient design than we might have otherwise. We strike a compromise between efficiency and implementation-independence.</font>
</p>


<p>
  <a name="2311"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Lastly, the JNI must be functionally <em>complete</em>. It must expose enough Java virtual machine functionality to enable native methods and applications to accomplish useful tasks.</font>
</p>


<p>
  <a name="2312"> </a><font face="Arial, Verdana, Helvetica, sans-serif">It is not the goal of JNI to be the only native programming interface supported by a given Java virtual machine implementation. A standard interface benefits programmers who would like to load their native code libraries into different Java virtual machine implementations. In some cases, however, a lower-level implementation-specific interface may achieve higher performance. In other cases, the programmer might use a higher-level interface to build software components.</font>
</p>

<a name="1974"></a>
<h2>11.2    Loading Native Libraries</h2>

<p>
  <a name="5146"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Before an application can invoke a native method, the virtual machine must locate and load a native library that contains an implementation of the native method.</font>
</p>

<a name="6600"></a>
<h3>11.2.1    Class Loaders</h3>

<p>
  <a name="9819"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native libraries are located by <em>class loaders</em>. Class loaders have many uses in the Java virtual machine including, for example, loading class files, defining classes and interfaces, providing namespace separation among software components, resolving symbolic references among different classes and interfaces, and finally, locating native libraries. We assume that you have a basic understanding of class loaders, so we will not go into the details of how they load and link classes in the Java virtual machine. You can find out more details on class loaders in the paper <em>Dynamic Class Loading in the Java Virtual Machine</em>, by Sheng Liang and Gilad Bracha, published in the proceedings of the ACM Conference on Object Oriented Programming Systems, Languages, and Applications (OOPSLA), 1998.</font>
</p>


<p>
  <a name="8598"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Class loaders provide the namespace separation needed to run multiple components (such as the applets downloaded from different web sites) inside an instance of the same virtual machine. A class loader maintains a separate namespace by mapping class or interface names to actual class or interface types represented as objects in the Java virtual machine. Each class or interface type is associated with its <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">defining loader</font>, the loader that initially reads the class file and defines the class or interface object. Two class or interface types are the same only when they have the same name and the same defining loader. For example, in Figure <a href="design.html#26112">11.1</a>, class loaders <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">1</font> and <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">2</font> each define a class named <code>C</code>. These two classes named <code>C</code> are not the same. Indeed, they contain two different <code>f</code> methods that have distinct return types. </font>
</p>


<p>
  <a name="6624"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><img src="designa.gif" height="299" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="26112"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 11.1	</b>&nbsp;&nbsp;Two classes of the same name loaded by different class loaders</font><p>
<p>
  <a name="6908"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The dotted lines in the above figure represent the <em>delegation</em> relationships among class loaders. A class loader may ask another class loader to load a class or an interface on its behalf. For example, both <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">1</font> and <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">2</font> delegate to the bootstrap class loader for loading the system class <code>java.lang.String</code>. Delegation allows system classes to be shared among all class loaders. This is necessary because type safety would be violated if, for example, application and system code had different notions of what the type <code>java.lang.String</code> was.</font>
</p>

<a name="8198"></a>
<h3>11.2.2    Class Loaders and Native Libraries</h3>

<p>
  <a name="6773"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Now suppose the method <code>f</code> in both classes <code>C</code> are native methods. The virtual machine locates the native implementation for both <code>C.f</code> methods using the name "<code>C_f</code>". To ensure that each <code>C</code> class links with the correct native function, each class loader must maintain its own set of native libraries, as shown in Figure <a href="design.html#26123">11.2</a>.</font>
</p>


<p>
  <a name="10339"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><img src="design3.gif" height="349" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="26123"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 11.2	</b>&nbsp;&nbsp;Associating native libraries with class loaders</font><p>
<p>
  <a name="10341"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Because each class loader maintains a set of native libraries, the programmer may use a single library to store all the native methods needed by any number of classes as long as those classes have the same defining loader. </font>
</p>


<p>
  <a name="10340"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native libraries will automatically be unloaded by the virtual machine when their corresponding class loaders are garbage collected (<a href="design.html#14500">&#167;11.2.5</a>).</font>
</p>

<a name="6814"></a>
<h3>11.2.3    Locating Native Libraries</h3>

<p>
  <a name="2037"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native libraries are loaded by the <code>System.loadLibrary</code> method. In the following example, the static initializer of class <code>Cls</code> loads a platform-specific native library in which the native method <code>f</code> is defined:</font>
</p>

<pre>
<a name="2038"> </a>package pkg; 
<a name="2039"> </a>class Cls {
<a name="2040"> </a>     native double f(int i, String s);
<a name="2041"> </a>     static {
<a name="2042"> </a>         System.loadLibrary("mypkg");
<a name="2043"> </a>     }
<a name="2044"> </a>}
</pre>

<p>
  <a name="2564"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The argument to <code>System.loadLibrary</code> is a library name chosen by the programmer. Software developers are responsible for choosing native library names that minimize the chance of name clashes. The virtual machine follows a standard, but host environment specific, convention to convert the library name to a native library name. For example, the Solaris operating system converts the name <code>mypkg</code> to <code>libmypkg.so</code>, while the Win32 operating system converts the same <code>mypkg</code> name to <code>mypkg.dll</code>.</font>
</p>


<p>
  <a name="6964"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When the Java virtual machine starts up, it constructs a list of directories that will be used to locate native libraries for application classes. The contents of the list are dependent upon the host environment and the virtual machine implementation. For example, under the Win32 JDK or Java 2 SDK releases, the list of directories consists of the Windows system directories, the current working directory, and the entries in the <code>PATH</code> environment variable. Under the Solaris JDK or Java 2 SDK releases, the list of directories consists of the entries in the <code>LD_LIBRARY_PATH</code> environment variable.</font>
</p>


<p>
  <a name="10347"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>System.loadLibrary</code> throws an <code>UnsatisfiedLinkError</code> if it fails to load the named native library. <code>System.loadLibrary</code> completes silently if an earlier call to <code>System.loadLibrary</code> has already loaded the same native library. If the underlying operating system does not support dynamic linking, all native methods must be prelinked with the virtual machine. In this case, the virtual machine completes the <code>System.loadLibrary</code> calls without actually loading the library.</font>
</p>


<p>
  <a name="2558"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine internally maintains a list of loaded native libraries for each class loader. It follows three steps to determine which class loader should be associated with a newly loaded native library:</font>
</p>

<ol><font face="Arial, Verdana, Helvetica, sans-serif">
<li>determine the <em>immediate</em> caller of <code>System.loadLibrary
</code></font><li><font face="Arial, Verdana, Helvetica, sans-serif">identify the class that defines the caller
</font><li><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</ol>
<p>
  <a name="14559"> </a><font face="Arial, Verdana, Helvetica, sans-serif">In the following example, the native library <code>foo</code> will be associated with <code>C</code>'s defining loader:</font>
</p>

<pre>
<a name="14560"> </a>class C {
<a name="14562"> </a>    static {
<a name="14563"> </a>        System.loadLibrary("foo");
<a name="14564"> </a>    }
<a name="14561"> </a>}
</pre>

<p>
  <a name="8627"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Java 2 SDK release 1.2 introduces a new <code>ClassLoader.findLibrary</code> method that allows the programmer to specify a custom library loading policy that is specific to a given class loader. The <code>ClassLoader.findLibrary</code> method takes a platform-independent library name (such as <code>mypkg</code>) as an argument, and:</font>
</p>

<a name="8654"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>either returns <code>null</code> to instruct the virtual machine to follow the default library search path,</font><a name="8655"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>or returns a host-environment-dependent absolute path of the library file (such as "<code>c:\\mylibs\\mypkg.dll"</code>).</font>
</ul>
<p>
  <a name="20943"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>ClassLoader.findLibrary</code> is typically used with another method added in the Java 2 SDK release 1.2, <code>System.mapLibraryName. System.mapLibrary-Name</code> maps platform-independent library names (such as <code>mypkg</code>) to platform-dependent library file names (such as <code>mypkg.dll</code>).</font>
</p>


<p>
  <a name="8657"> </a><font face="Arial, Verdana, Helvetica, sans-serif">You can override the default library search path in Java 2 SDK release 1.2 by setting the property <code>java.library.path</code>. For example, the following command line starts up a program <code>Foo</code> which needs to load a native library in the <code>c:\mylibs</code> directory:</font>
</p>

<pre>
<a name="8661"> </a>java -Djava.library.path=c:\mylibs Foo
</pre>
<a name="8628"></a>
<h3>11.2.4    A Type Safety Restriction</h3>

<p>
  <a name="10332"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine does not allow a given JNI native library to be loaded by more than one class loader. Attempting to load the same native library by multiple class loaders causes an <code>UnsatisfiedLinkError</code> to be thrown. The purpose of this restriction is to make sure that namespace separation based on class loaders is preserved in native libraries. Without this restriction, it becomes much easier to mistakenly intermix classes and interfaces from different class loaders through native methods. Consider a native method <code>Foo.f</code> that caches its own defining class <code>Foo</code> in a global reference:</font>
</p>

<pre>
<a name="20992"> </a>JNIEXPORT void JNICALL
<a name="20987"> </a>Java_Foo_f(JNIEnv *env, jobject self)
<a name="21004"> </a>{
<a name="21005"> </a>    static jclass cachedFooClass; /* cached class Foo */
<a name="20993"> </a>    if (cachedFooClass == NULL) {
<a name="21007"> </a>        jclass fooClass = (*env)-&gt;FindClass(env, "Foo");
<a name="21010"> </a>        if (fooClass == NULL) {
<a name="21013"> </a>            return; /* error */
<a name="21014"> </a>        }
<a name="21011"> </a>        cachedFooClass = (*env)-&gt;NewGlobalRef(env, fooClass);
<a name="21012"> </a>        if (cachedFooClass == NULL) {
<a name="21015"> </a>            return; /* error */
<a name="21016"> </a>        }
<a name="21006"> </a>    }
<a name="21675"> </a>    assert((*env)-&gt;IsInstanceOf(env, self, cachedFooClass));
<a name="21017"> </a>    ... /* use cachedFooClass */
<a name="20989"> </a>}
</pre>

<p>
  <a name="21022"> </a><font face="Arial, Verdana, Helvetica, sans-serif">We expect the assertion to succeed because <code>Foo.f</code> is an instance method and <code>self</code> refers to an instance of <code>Foo</code>. The assertion could fail, however, if two different <code>Foo</code> classes are loaded by class loaders <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">1</font> and <code>L</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">2</font> and both <code>Foo</code> classes are linked with the previous implementation of <code>Foo.f</code>. The <code>cachedFooClass</code> global reference will be created for the <code>Foo</code> class whose <code>f</code> method is invoked first. A later invocation of the <code>f</code> method of the other <code>Foo</code> class will cause the assertion to fail.</font>
</p>


<p>
  <a name="6974"> </a><font face="Arial, Verdana, Helvetica, sans-serif">JDK release 1.1 did not properly enforce native library separation among class loaders. This means that it would be possible for two classes in different class loaders to link with the same native method. As shown by the previous example, the approach in JDK release 1.1 leads to the following two problems:</font>
</p>

<a name="6975"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>A class may mistakenly link with native libraries that were loaded by a class with the same name in a different class loader.</font><a name="9974"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Native methods can easily mix classes from different class loaders. This breaks the namespace separation offered by class loaders, and leads to type safety problems.</font>
</ul><a name="14500"></a>
<h3>11.2.5    Unloading Native Libraries</h3>

<p>
  <a name="14501"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine unloads a native library after it garbage collects the class loader associated with the native library. Because classes refer to their defining loaders, this implies that the virtual machine has also unloaded the class whose static initializer called <code>System.loadLibrary</code> and loaded the native library (<a href="design.html#8198">&#167;11.2.2</a>).</font>
</p>

<a name="9984"></a>
<h2>11.3    Linking Native Methods</h2>

<p>
  <a name="9932"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine attempts to link each native method before invoking it for the first time. The earliest time that a native method <code>f</code> can be linked is the first invocation of a method <code>g</code>, where there is a reference from the method body of <code>g</code> to <code>f</code>. Virtual machine implementations should not try to link a native method too early. Doing so could lead to unexpected linkage errors because the native library that implements the native method may not have been loaded.</font>
</p>


<p>
  <a name="14571"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Linking a native method involves the following steps:</font>
</p>

<a name="10377"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Determining the class loader of the class that defines the native method.</font><a name="10379"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Searching the set of native libraries associated with this class loader to locate the native function that implements the native method.</font><a name="10385"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Setting up the internal data structures so that all future calls to the native method will jump directly to the native function.</font>
<p>
  <a name="10366"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine deduces the name of the native function from the name of the native method by concatenating the following components:</font>
</p>

<a name="9934"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>the prefix "<code>Java_</code>"</font><a name="9935"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>an encoded fully qualified class name</font><a name="9936"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>an underscore ("<code>_</code>") separator</font><a name="9937"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>an encoded method name</font><a name="9938"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>for overloaded native methods, two underscores ("<code>__</code>") followed by the encoded argument descriptor</font>
</ul>
<p>
  <a name="9939"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The virtual machine iterates through all native libraries associated with the defining loader to search for a native function with an appropriate name. For each native library, the virtual machine looks first for the short name, that is, the name without the argument descriptor. It then looks for the long name, which is the name with the argument descriptor. Programmers need to use the long name only when a native method is overloaded with another native method. However, this is not a problem if the native method is overloaded with a non-native method. The latter does not reside in a native library. </font>
</p>


<p>
  <a name="9940"> </a><font face="Arial, Verdana, Helvetica, sans-serif">In the following example, the native method <code>g</code> does not have to be linked using the long name because the other method <code>g</code> is not a native method.</font>
</p>

<pre>
<a name="9941"> </a>class Cls1 {
<a name="9942"> </a>    int g(int i) { ... } // regular method
<a name="9943"> </a>    native int g(double d);
<a name="9944"> </a>}
</pre>

<p>
  <a name="9945"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI adopts a simple name-encoding scheme to ensure that all Unicode characters translate into valid C function names. The underscore ("<code>_</code>") character separates the components of fully qualified class names. <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">Because a name or type descriptor never begins with a number, we can use </font><code>_0</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">, </font>...<font  size="2" face="Arial, Verdana, Helvetica, sans-serif">, </font><code>_9</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"> for escape sequences, as illustra</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">ted below:<p>
<table border="1" bordercolorlight="#FFFFFF" bordercolordark="#000000"
       cellpadding="5" cellspacing="0">
  <caption ALIGN="left"><b><font face="Arial, Verdana, Helvetica, sans-serif" size="-1"></font></b></caption>
  <tr bgcolor="#CCCCCC"><div align="center">
    <th><font face="Arial, Verdana, Helvetica, sans-serif" color="#663300">
<a name="9948"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">Escape Sequence<br></font>

</font></th>
    <th><font face="Arial, Verdana, Helvetica, sans-serif" color="#663300">
<a name="9950"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">Denotes <br></font>

</font></th>
  </div></tr>
  <tr>
    <td>

<a name="9952"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"> <code>_0XXXX</code><br></font>

</td>
    <td>

<p>
  <a name="9954"> </a><font face="Arial, Verdana, Helvetica, sans-serif">a Unicode character<font  size="2" face="Arial, Verdana, Helvetica, sans-serif"> </font><code>XXXX</code></font>
</p>

</td>
  </tr>
  <tr>
    <td>

<a name="9956"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"><code>_1</code> <br></font>

</td>
    <td>

<p>
  <a name="9958"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">t</font>he character <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">"</font><code>_</code><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">"</font></font>
</p>

</td>
  </tr>
  <tr>
    <td>

<a name="9960"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"><code>_2</code> <br></font>

</td>
    <td>

<p>
  <a name="9962"> </a><font face="Arial, Verdana, Helvetica, sans-serif">the character "<code>;</code>" in descriptors</font>
</p>

</td>
  </tr>
  <tr>
    <td>

<a name="9964"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"><code>_3</code> <br></font>

</td>
    <td>

<p>
  <a name="9966"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">t</font>he character "<code>[</code>" in descriptors</font>
</p>

</td>
  </tr>
</table>


</p>
<br></font></font>
</p>


<p>
  <a name="9967"> </a><font face="Arial, Verdana, Helvetica, sans-serif">If native functions matching an encoded native method name are present in multiple native libraries, the function in the native library that is loaded first is linked with the native method. If no function matches the native method name, an <code>UnsatisfiedLinkError</code> is thrown.</font>
</p>


<p>
  <a name="9968"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The programmer can also call the JNI function <code>RegisterNatives</code> to register the native methods associated with a class. The <code>RegisterNatives</code> function is particularly useful with statically linked functions.</font>
</p>

<a name="8330"></a>
<h2>11.4    Calling Conventions</h2>

<p>
  <a name="8331"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The calling convention determines how a native function receives arguments and returns results. There is no standard calling convention among various native languages, or among different implementations of the same language. For example, it is common for different C++ compilers to generate code that follows different calling conventions.</font>
</p>


<p>
  <a name="6559"> </a><font face="Arial, Verdana, Helvetica, sans-serif">It would be difficult, if not impossible, to require the Java virtual machine to interoperate with a wide variety of native calling conventions. The JNI requires the native methods to be written in a specified standard calling convention on a given host environment. For example, the JNI follows the C calling convention on UNIX and the <code>stdcall</code> convention on Win32.</font>
</p>


<p>
  <a name="8334"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When programmers need to call functions that follow a different calling convention, they must write stub routines that adapt the JNI calling conventions to those of the appropriate native language.</font>
</p>

<a name="8371"></a>
<h2>11.5    The <font  size="4" face="Arial, Verdana, Helvetica, sans-serif">JNIEnv</font> Interface Pointer</h2>

<p>
  <a name="5166"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native code accesses virtual machine functionality by calling various functions exported through the <code>JNIEnv</code> <em>interface pointer</em>. </font>
</p>

<a name="10110"></a>
<h3>11.5.1    Organization of the <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">JNIEnv</font> Interface Pointer</h3>

<p>
  <a name="10109"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A <code>JNIEnv</code> interface pointer is a pointer to thread-local data, which in turn contains a pointer to a function table. Every interface function is at a predefined offset in the table. The <code>JNIEnv</code> interface is organized like a C++ virtual function table and is also like a Microsoft COM interface. Figure <a href="design.html#27433">11.3</a><a href="design.html#10109"></a> illustrates a set of <code>JNIEnv</code> interface pointers.<img src="design2.gif" height="431" width="491" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="27433"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 11.3	</b>&nbsp;&nbsp;Thread Local <code>JNIEnv</code> Interface Pointers</font><p>
<p>
  <a name="27431"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Functions that implement a native method receive the <code>JNIEnv</code> interface pointer as their first argument. The virtual machine is guaranteed to pass the same interface pointer to native method implementation functions called from the same thread. However, a native method can be called from different threads, and therefore may be passed different <code>JNIEnv</code> interface pointers. Although the interface pointer is thread-local, the doubly indirected JNI function table is shared among multiple threads. </font>
</p>


<p>
  <a name="5217"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The reason the <code>JNIEnv</code> interface pointer refers to a thread-local structure is that some platforms do not have efficient support for thread-local storage access. By passing around a thread-local pointer, the JNI implementation inside the virtual machine can avoid many thread-local storage access operations that it would otherwise have to perform. </font>
</p>


<p>
  <a name="5505"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Because the <code>JNIEnv</code> interface pointer is thread-local, native code must not use the <code>JNIEnv</code> interface pointer belonging to one thread in another thread. Native code may use the <code>JNIEnv</code> pointer as a thread ID that remains unique for the lifetime of the thread.</font>
</p>

<a name="10111"></a>
<h3>11.5.2    Benefits of an Interface Pointer</h3>

<p>
  <a name="5506"> </a><font face="Arial, Verdana, Helvetica, sans-serif">There are several advantages of using an interface pointer, as opposed to hard-wired function entries:</font>
</p>

<a name="5507"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Most importantly, because the JNI function table is passed as an argument to each native method, native libraries do not have to link with a particular implementation of the Java virtual machine. This is crucial because different vendors may name their virtual machine implementations differently. Having each native library be self-contained is a prerequisite for the same native library binary to work with virtual machine implementations from different vendors on a given host environment.</font><a name="5508"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Second, by not using hard-wired function entries, a virtual machine implementation may choose to provide multiple versions of JNI function tables. For example, the virtual machine implementation may support two JNI function tables: one performs thorough illegal argument checks, and is suitable for debugging; the other performs the minimal amount of checking required by the JNI specification, and is therefore more efficient. Java 2 SDK release 1.2 supports a <code>-Xcheck:jni</code> option that optionally turns on additional checks for JNI functions.</font><a name="14604"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Finally, multiple JNI function tables make it possible to support multiple versions of <code>JNIEnv</code>-like interfaces in the future. Although we do not yet foresee the need to do so, a future version of the Java platform can support a new JNI function table, in addition to the one pointed to by the <code>JNIEnv</code> interface in the 1.1 and 1.2 releases. Java 2 SDK release 1.2 introduces a <code>JNI_Onload</code> function, which can be defined by a native library to indicate the version of the JNI function table needed by the native library. Future implementations of Java virtual machines can simultaneously support multiple versions of JNI function tables, and pass the correct version to individual native libraries depending upon their needs.</font>
</ul><a name="5512"></a>
<h2>11.6    Passing Data</h2>

<p>
  <a name="5551"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Primitive data types, such as integers, characters, and so on, are copied between the Java virtual machine and native code. Objects, on the other hand, are passed by reference. Each reference contains a direct pointer to the underlying object. The pointer to the object is never directly used by native code. From the native code's point of view, references are opaque.</font>
</p>


<p>
  <a name="6986"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Passing references, instead of direct pointers to objects, enables the virtual machine to manage objects in more flexible ways. Figure <a href="design.html#27456">11.4</a> illustrates one such flexibility. While native code is holding a reference, the virtual machine may perform a garbage collection that results in the object being copied from one area of memory to another. The virtual machine can automatically update the content of the reference so that although the object has moved, the reference is still valid.</font>
</p>


<p>
  <a name="6987"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><img src="design4.gif" height="200" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="27456"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 11.4	</b>&nbsp;&nbsp;Relocating an Object while Native Code Holds a Reference</font><p><a name="8414"></a>
<h3>11.6.1    Global and Local References</h3>

<p>
  <a name="2150"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI creates two kinds of object references for native code: local and global references. Local references are valid for the duration of a native method invocation and are automatically freed after the native method returns. Global references remain valid until they are explicitly freed.</font>
</p>


<p>
  <a name="2151"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Objects are passed to native methods as local references. Most JNI functions return local references. The JNI allows the programmer to create global references from local references. JNI functions that take objects as arguments accept both global and local references. A native method may return either a local or a global reference to the virtual machine as its result.</font>
</p>


<p>
  <a name="2624"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Local references are only valid in the thread in which they are created. Native code must not pass local references from one thread to another.</font>
</p>


<p>
  <a name="21771"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A <code>NULL</code> reference in the JNI refers to the <code>null</code> object in the Java virtual machine. A local or global reference whose value is not <code>NULL</code> does not refer to a <code>null</code> object.</font>
</p>

<a name="2157"></a>
<h3>11.6.2    Implementing Local References</h3>

<p>
  <a name="7901"> </a><font face="Arial, Verdana, Helvetica, sans-serif">To implement local references, the Java virtual machine creates a registry for each transition of control from the virtual machine to a native method. A registry maps nonmovable local references to object pointers. Objects in the registery cannot be garbage collected. All objects passed to the native method, including those that are returned as the results of JNI function calls, are automatically added to the registry. The registry is deleted after the native method returns, allowing its entries to be garbage collected. Figure <a href="design.html#27447">11.5</a> illustrates how the local references registry is created and deleted. The Java virtual machine frame that corresponds to the native method contains a pointer to the local reference registry. A method <code>D.f</code> calls native method <code>C.g</code>. <code>C.g</code> is implemented by the C function <code>Java_C_g</code>. The virtual machine creates a local reference registry before entering <code>Java_C_g</code> and deletes the local reference registry after <code>Java_C_g</code> returns.</font>
</p>


<p>
  <a name="8086"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><img src="design5.gif" height="245" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="27447"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 11.5	</b>&nbsp;&nbsp;Creating and Deleting a Local Reference Registry</font><p>
<p>
  <a name="2159"> </a><font face="Arial, Verdana, Helvetica, sans-serif">There are different ways to implement a registry, such as using a stack, a table, a linked list, or a hash table. Although reference counting may be used to avoid duplicated entries in the registry, a JNI implementation is not obliged to detect and collapse duplicate entries.</font>
</p>


<p>
  <a name="2160"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Local references cannot be implemented faithfully by conservatively scanning the native stack. Native code may store local references into global or C heap data structures.</font>
</p>

<a name="2745"></a>
<h3>11.6.3    Weak Global References</h3>

<p>
  <a name="7170"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Java 2 SDK release 1.2 introduces a new kind of global reference: weak global references. Unlike normal global references, a weak global reference allows the referenced object to be garbage collected. After the underlying object is garbage collected, a weak global reference is cleared. Native code can test whether a weak global reference is cleared by using <code>IsSameObject</code> to compare the reference against <code>NULL</code>.</font>
</p>

<a name="7220"></a>
<h2>11.7    Accessing Objects</h2>

<p>
  <a name="2162"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI provides a rich set of accessor functions for references to objects. This means that the same native method implementation works no matter how the virtual machine represents objects internally. This is a crucial design decision enabling the JNI to be supported by any virtual machine implementation.</font>
</p>


<p>
  <a name="2163"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">The overhead of using accessor functions through opaque references is higher than that of direct access to C data structures. We believe that, in most cases, native methods perform nontrivial tasks that overshadow the cost of the extra function call. </font></font>
</p>

<a name="2164"></a>
<h3>11.7.1    Accessing Primitive Arrays</h3>

<p>
  <a name="2165"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The function call overhead is not acceptable, however, for repeated access to values of primitive data types in large objects, such as integer arrays and strings. Consider native methods that are used to perform vector and matrix calculations. It would be grossly inefficient to iterate through an integer array and retrieve every element with a function call.</font>
</p>


<p>
  <a name="2166"> </a><font face="Arial, Verdana, Helvetica, sans-serif">One solution introduces a notion of "pinning" so that the native method can ask the virtual machine not to move the contents of an array. The native method then receives a direct pointer to the elements. This approach, however, has two implications:</font>
</p>

<a name="2167"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>The garbage collector must support pinning. In many implementations, pinning is undesirable because it complicates garbage collection algorithms and leads to memory fragmentation.</font><a name="2168"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>The virtual machine must lay out primitive arrays contiguously in memory. Although this is the natural implementation for most primitive arrays, boolean arrays can be implemented as packed or unpacked. A packed boolean array uses one bit for each element, whereas an unpacked one typically uses one byte for each element. Therefore, native code that relies on the exact layout of boolean arrays will not be portable.</font>
</ul>
<p>
  <a name="2169"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI adopts a compromise that addresses both of the above problems.</font>
</p>


<p>
  <a name="2170"> </a><font face="Arial, Verdana, Helvetica, sans-serif">First, the JNI provides a set of functions (for example, <code>GetIntArrayRegion</code> and <code>SetIntArrayRegion</code>) to copy primitive array elements between a segment of a primitive array and a native memory buffer. Use these functions if the native method needs to access only a small number of elements in a large array or if the native method needs to make a copy of the array anyway.</font>
</p>


<p>
  <a name="2171"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Second, programmers can use another set of functions (for example, <code>GetInt-ArrayElements</code>) to try to obtain a pinned version of array elements. Depending upon the virtual machine implementation, however, these functions may cause storage allocation and copying. Whether these functions in fact copy the array depends upon the virtual machine implementation as follows:</font>
</p>

<a name="2172"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>If the garbage collector supports pinning, and the layout of the array is the same as that of a native array of the same type, then no copying is needed.   </font><a name="2173"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Otherwise, the array is copied to a nonmovable memory block (for example, in the C heap) and the necessary format conversion is performed. A pointer to the copy is returned. </font>
</ul>
<p>
  <a name="5597"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native code calls a third set of functions (for example, <code>ReleaseInt-ArrayElements</code>) to inform the virtual machine that the native code no longer needs to access the array elements. When that happens, the virtual machine either unpins the array or reconciles the original array with its nonmovable copy and frees the copy.</font>
</p>


<p>
  <a name="8427"> </a><font face="Arial, Verdana, Helvetica, sans-serif">This approach provides flexibility. A garbage collector algorithm can make separate decisions about copying or pinning for each array. Under a particular implementation scheme the garbage collector might copy small arrays, but pin large arrays.</font>
</p>


<p>
  <a name="37920"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Finally, Java 2 SDK release 1.2 introduces two new functions: <code>GetPrimitiveArrayCritical</code> and <code>ReleasePrimitiveArrayCritical</code>. These functions can be used in ways similar to, for example, <code>GetIntArrayElements</code> and <code>ReleaseInt-ArrayElements</code>. There are, however, significant restrictions on the native code after it obtains a pointer to array elements using <code>GetPrimitiveArrayCritical</code> and before it releases the pointer using <code>ReleasePrimitiveArrayCritical</code>. Inside a "critical region" the native code should not run for an indefinite period of time, must not invoke arbitrary JNI functions, and must not perform operations that might cause the current thread to block and wait for another thread in the virtual machine. Given these restrictions, the virtual machine can temporarily disable garbage collection while giving the native code direct access to array elements. Because no pinning support is needed, <code>GetPrimitiveArrayCritical</code> is more likely to return a direct pointer to the primitive array elements than, for example, <code>GetIntArrayElements</code>.</font>
</p>


<p>
  <a name="10124"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A JNI implementation must ensure that native methods running in multiple threads can simultaneously access the same array. For example, the JNI may keep an internal counter for each pinned array so that one thread does not unpin an array that is also pinned by another thread. Note that the JNI does not need to lock primitive arrays for exclusive access by a native method. Simultaneously updating an array from different threads is allowed, although this leads to nondeterministic results.</font>
</p>

<a name="10125"></a>
<h3>11.7.2    Fields and Methods</h3>

<p>
  <a name="10126"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI allows native code to access fields and to call methods defined in the Java programming language. The JNI identifies methods and fields by their symbolic names and type descriptors. A two-step process factors out the cost of locating the field or method from its name and descriptor. For example, to read an integer instance field <code>i</code> in class <code>cls</code>, native code first obtains a field ID, as follows:</font>
</p>

<pre>
<a name="2179"> </a>jfieldID fid = env-&gt;GetFieldID(env, cls, "i", "I");
</pre>

<p>
  <a name="2180"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The native code can then use the field ID repeatedly, without the cost of field lookup, as follows:</font>
</p>

<pre>
<a name="2181"> </a>jint value = env-&gt;GetIntField(env, obj, fid);
</pre>

<p>
  <a name="2182"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A field or method ID remains valid until the virtual machine unloads the class or interface that defines the corresponding field or method. After the class or interface is unloaded, the method or field ID becomes invalid. </font>
</p>


<p>
  <a name="8765"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Programmers can derive a field or method ID from the classes or interfaces where the corresponding field or method can be resolved. The field or method can be defined in the class or interface itself or inherited from superclasses or superinterfaces. <em>The Java</em><font size="-1"><sup>TM</sup></font><em> Virtual Machine Specification</em> contains the precise rules of resolving fields and methods. <em>The JNI implementation must derive the same field or method ID for a given name and descriptor from two classes or interfaces if the same field or method definition is resolved from these two classes or interfaces.</em> For example, if <code>B</code> defines field <code>fld</code>, and <code>C</code> inherits <code>fld</code> from <code>B</code>, then the programmer is guaranteed to obtain the same field ID for field name <code>"fld"</code> from both classes <code>B</code> and <code>C</code>.</font>
</p>


<p>
  <a name="8761"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI does not impose any restrictions on how field and method IDs are implemented internally.</font>
</p>


<p>
  <a name="8462"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Note that you need both the field name and field descriptor to obtain a field ID from a given class or interface. This might seem unnecessary because fields cannot be overloaded in the Java programming language. It is legal, however, to have overloaded fields in a class file, and to run such class files on Java virtual machines. Therefore, the JNI is able to handle legal class files that are not generated by a compiler for the Java programming language.</font>
</p>


<p>
  <a name="2634"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Programmers can use the JNI to call methods or access fields only if they already know the names and types of the methods or fields. In comparison, the Java Core Reflection API allows programmers to determine the set of fields and methods in a given class or interface. It is sometimes useful to be able to reflect on class or interface types in native code as well. Java 2 SDK release 1.2 provides new JNI functions that are designed to work with the existing Java Core Reflection API. The new functions include one pair that converts between JNI field IDs and instances of the <code>java.lang.reflect.Field</code> class, and another pair that converts between JNI method IDs and instances of the <code>java.lang.reflect.Method</code> class.</font>
</p>

<a name="2187"></a>
<h2>11.8    Errors and Exceptions</h2>

<p>
  <a name="5703"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Errors made in JNI programming are different from exceptions that occur in the Java virtual machine implementation. Programmer errors are caused by misuses of JNI functions. The programmer, for example, may mistakenly pass an object reference instead of a class reference to <code>GetField-ID</code>. Java virtual machine exceptions are raised, for example, by out-of-memory situations that occur when native code tries to allocate an object through the JNI.</font>
</p>

<a name="5626"></a>
<h3>11.8.1    No Checking for Programming Errors</h3>

<p>
  <a name="2188"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI functions do not check for programming errors. Passing illegal arguments to JNI functions results in undefined behavior. The reason for this design decision is as follows:</font>
</p>

<a name="2189"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Forcing JNI functions to check for all possible error conditions degrades the performance in all (typically correct) native methods.</font><a name="2190"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>In many cases there is not enough runtime type information to perform such checking.</font>
</ul>
<p>
  <a name="2191"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Most C library functions do not guard against programming errors. The <code>printf</code> function, for example, usually triggers a runtime error instead of returning an error code when it receives an invalid address. Forcing C library functions to check for all possible error conditions would likely result in such checks being duplicated, once in the user code and then again in the library.</font>
</p>


<p>
  <a name="5628"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Although the JNI specification does not require the virtual machine to check for programming errors, virtual machine implementations are encouraged to  provide checks for common mistakes. For example, a virtual machine may perform more checking in a debug version of the JNI function table (<a href="design.html#10111">&#167;11.5.2</a>).</font>
</p>

<a name="2193"></a>
<h3>11.8.2    Java Virtual Machine Exceptions</h3>

<p>
  <a name="8506"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI does not rely on exception handling mechanisms in native programming languages. Native code may cause the Java virtual machine to throw an exception by calling <code>Throw</code> or <code>ThrowNew</code>. A pending exception is recorded in the current thread. Unlike exceptions thrown in the Java programming language, exceptions thrown in native code do not immediately disrupt the current execution. </font>
</p>


<p>
  <a name="14542"> </a><font face="Arial, Verdana, Helvetica, sans-serif">There is no standard exception handling mechanism in native languages. Thus, JNI programmers are expected to check for and handle exceptions after each operation that can potentially throw an exception. JNI programmers may deal with an exception in two ways:</font>
</p>

<a name="8478"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>The native method may choose to return immediately, causing the exception to be thrown in the code that initiated the native method call.</font><a name="8479"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>The native code may clear the exception by calling <code>ExceptionClear</code> and then execute its own exception-handling code.</font>
</ul>
<p>
  <a name="37857"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">It is extremely important to check, handle, and clear a pending exception before calling any subsequent JNI functions</font>. Calling most JNI functions with a pending exception leads to undefined results. The following is the complete list of JNI functions that can be called safely when there is a pending exception:</font>
</p>

<pre>
<a name="37858"> </a><code>ExceptionOccurred
</code><a name="37859"> </a><code>ExceptionDescribe
</code><a name="37860"> </a><code>ExceptionClear
</code><a name="37861"> </a>ExceptionCheck
<a name="37862"> </a>
<a name="37863"> </a><code>ReleaseStringChars
</code><a name="37864"> </a><code>ReleaseStringUTFchars
</code><a name="37865"> </a><code>ReleaseStringCritical
</code><a name="37866"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">Release&lt;Type&gt;ArrayElements
</font><a name="37867"> </a><code>ReleasePrimitiveArrayCritical
</code><a name="37868"> </a>DeleteLocalRef
<a name="37869"> </a>DeleteGlobalRef
<a name="37870"> </a>DeleteWeakGlobalRef
<a name="37871"> </a>MonitorExit
</pre>

<p>
  <a name="37855"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The first four functions are directly related to exception handling. The remaining ones are common in that they release various virtual machine resources exposed through the JNI. It is often necessary to be able to free resources when exceptions occur.</font>
</p>

<a name="2203"></a>
<h3>11.8.3    Asynchronous Exceptions</h3>

<p>
  <a name="2204"> </a><font face="Arial, Verdana, Helvetica, sans-serif">One thread may raise an asynchronous exception in another thread by calling <code>Thread.stop</code>.  An asynchronous exception does not affect the execution of native code in the current thread until:</font>
</p>

<a name="2205"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>the native code calls one of the JNI functions that could raise synchronous exceptions, or</font><a name="2206"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>the native code uses <code>ExceptionOccurred</code> to check for synchronous and asynchronous exceptions explicitly.</font>
</ul>
<p>
  <a name="2207"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Only those JNI functions that could potentially raise synchronous exceptions check for asynchronous exceptions.</font>
</p>


<p>
  <a name="2208"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native methods may insert <code>ExceptionOccurred</code> checks in necessary places (such as in tight loops without other exception checks) to ensure that the current thread responds to asynchronous exceptions in a reasonable amount of time. </font>
</p>


<p>
  <a name="5633"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The Java thread API that generates asynchronous exceptions, <code>Thread.stop</code>, has been deprecated in Java 2 SDK release 1.2. Programmers are strongly discouraged from using <code>Thread.stop</code> because it generally leads to unreliable programs. This is particularly a problem for JNI code. For example, many JNI libraries written today do not carefully follow the rules of checking for asynchronous exceptions described in this section. </font>
</p>



<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="part3.html">Prev</a> | <a href="types.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<p>
<font size="-1"><i><a href="copyright.html">Copyright</a> &#169 2002 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jni@java.sun.com">jni@java.sun.com</a>
</font>
</body></html>