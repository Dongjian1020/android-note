<html>
<head>
<title> Exceptions</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="refs.html">Prev</a> | <a href="invoke.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<hr><br>
 
<div align="right">
<h1 align="left">
  <a name="11201"> </a><font color="#663300" face="Arial, Verdana, Helvetica, sans-serif">Chapter 6 chapter</font>
</h1>
</div>
<a name="11202"></a>
<h1>Exceptions</h1>
<hr><p>

<p>
  <a name="11203"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="7" face="Arial, Verdana, Helvetica, sans-serif">W</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">e</font> have encountered numerous situations in which native code checks for possible errors after making JNI function calls. This chapter examines how native code can detect and recover from these error conditions.</font>
</p>


<p>
  <a name="26021"> </a><font face="Arial, Verdana, Helvetica, sans-serif">We will focus on errors that occur as the result of issuing JNI function calls, not arbitrary errors that happen in native code. If a native method makes an operating systems call, it simply follows the documented way of checking for possible failures in the system call. If, on the other hand, the native method issues a callback to a Java API method, then it must follow the steps described in this chapter to properly check for and recover from possible exceptions that have occurred in the method execution.</font>
</p>

<a name="26039"></a>
<h2>6.1    Overview</h2>

<p>
  <a name="26376"> </a><font face="Arial, Verdana, Helvetica, sans-serif">We introduce JNI exception handling functions through a series of examples.</font>
</p>

<a name="26377"></a>
<h3>6.1.1    Caching and Throwing Exceptions in Native Code</h3>

<p>
  <a name="26024"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The program below shows how to declare a native method that throws an exception. The <code>CatchThrow</code> class declares the <code>doit</code> native method and specifies that it throws an <code>IllegalArgumentException</code>:</font>
</p>

<pre>
<a name="4616"> </a>class CatchThrow {
<a name="4617"> </a>    private native void doit() 
<a name="8361"> </a>        throws IllegalArgumentException;
<a name="4618"> </a>    private void callback() throws NullPointerException {
<a name="4619"> </a>        throw new NullPointerException("CatchThrow.callback");
<a name="4620"> </a>    }
<a name="46662"> </a>
<a name="46663"> </a>
<a name="46664"> </a>
<a name="46665"> </a>
<a name="46666"> </a>
<a name="4621"> </a>    public static void main(String args[]) {
<a name="4622"> </a>        CatchThrow c = new CatchThrow();
<a name="4623"> </a>        try {
<a name="4624"> </a>            c.doit();
<a name="4625"> </a>        } catch (Exception e) {
<a name="4626"> </a>            System.out.println("In Java:\n\t" + e);
<a name="4627"> </a>        }
<a name="4628"> </a>    }
<a name="4629"> </a>    static {
<a name="4630"> </a>        System.loadLibrary("CatchThrow");
<a name="4631"> </a>    }
<a name="4632"> </a>}
</pre>

<p>
  <a name="4638"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The <code>CatchThrow.main</code> method calls the native method <code>doit</code>, implemented as follows:</font>
</p>

<pre>
<a name="4642"> </a>JNIEXPORT void JNICALL 
<a name="5462"> </a>Java_CatchThrow_doit(JNIEnv *env, jobject obj)
<a name="4643"> </a>{
<a name="4644"> </a>    jthrowable exc;
<a name="5738"> </a>    jclass cls = (*env)-&gt;GetObjectClass(env, obj);
<a name="4645"> </a>    jmethodID mid = 
<a name="8368"> </a>        (*env)-&gt;GetMethodID(env, cls, "callback", "()V");
<a name="4647"> </a>    if (mid == NULL) {
<a name="4648"> </a>        return;
<a name="9687"> </a>    }
<a name="4649"> </a>    (*env)-&gt;CallVoidMethod(env, obj, mid);
<a name="4650"> </a>    exc = (*env)-&gt;ExceptionOccurred(env);
<a name="4651"> </a>    if (exc) {
<a name="4652"> </a>        /* We don't do much with the exception, except that
<a name="32350"> </a>           we print a debug message for it, clear it, and 
<a name="32353"> </a>           throw a new exception. */
<a name="4655"> </a>        jclass newExcCls;
<a name="4657"> </a>        (*env)-&gt;ExceptionDescribe(env);
<a name="4658"> </a>        (*env)-&gt;ExceptionClear(env);
<a name="4660"> </a>        newExcCls = (*env)-&gt;FindClass(env, 
<a name="5745"> </a>                      "java/lang/IllegalArgumentException");
<a name="4661"> </a>        if (newExcCls == NULL) {
<a name="5746"> </a>            /* Unable to find the exception class, give up. */
<a name="4662"> </a>            return;
<a name="9686"> </a>        }
<a name="4663"> </a>        (*env)-&gt;ThrowNew(env, newExcCls, "thrown from C code");
<a name="4664"> </a>    }
<a name="4665"> </a>}
</pre>

<p>
  <a name="46667"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46668"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="8381"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Running the program with the native library produces the following output:</font>
</p>

<pre>
<a name="8387"> </a>java.lang.NullPointerException:
<a name="8388"> </a>        at CatchThrow.callback(CatchThrow.java)
<a name="8389"> </a>        at CatchThrow.doit(Native Method)
<a name="8390"> </a>        at CatchThrow.main(CatchThrow.java)
<a name="8391"> </a>In Java:
<a name="8392"> </a>        java.lang.IllegalArgumentException: thrown from C code
</pre>

<p>
  <a name="4680"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The callback method throws a <code>NullPointerException</code>. When the <code>CallVoidMethod</code> returns control to the native method, the native code will detect this exception by calling the JNI function <code>ExceptionOccurred</code>. In our example, when an exception is detected, the native code outputs a descriptive message about the exception by calling <code>ExceptionDescribe</code>, clears the exception using <code>ExceptionClear</code>, and throws an <code>IllegalArgumentException</code> instead.</font>
</p>


<p>
  <a name="26051"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A pending exception raised through the JNI (by calling <code>ThrowNew</code>, for example) does not immediately disrupt the native method execution. This is different from how exceptions behave in the Java programming language. When an exception is thrown in the Java programming language, the virtual machine automatically transfers the control flow to the nearest enclosing <code>try/catch</code> statement that matches the exception type. The virtual machine then clears the pending exception and executes the exception handler. In contrast, JNI programmers must explicitly implement the control flow after an exception has occurred.</font>
</p>

<a name="26050"></a>
<h3>6.1.2    A Utility Function</h3>

<p>
  <a name="26012"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Throwing an exception involves first finding the exception class and then issuing a call to the <code>ThrowNew</code> function. To simplify the task, we can write a utility function that throws a named exception:</font>
</p>

<pre>
<a name="26013"> </a>void
<a name="26014"> </a>JNU_ThrowByName(JNIEnv *env, const char *name, const char *msg)
<a name="26015"> </a>{
<a name="26016"> </a>    jclass cls = (*env)-&gt;FindClass(env, name);
<a name="26017"> </a>    /* if cls is NULL, an exception has already been thrown */
<a name="26906"> </a>    if (cls != NULL) {
<a name="26018"> </a>        (*env)-&gt;ThrowNew(env, cls, msg);
<a name="26019"> </a>    }
<a name="26912"> </a>    /* free the local ref */
<a name="26909"> </a>    (*env)-&gt;DeleteLocalRef(env, cls);
<a name="26020"> </a>}
</pre>

<p>
  <a name="26063"> </a><font face="Arial, Verdana, Helvetica, sans-serif">In this book, the <code>JNU</code> prefix stands for <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">JN</font>I <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">U</font>tilities. <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">JNU_ThrowByName</font> first finds the exception class using the <code>FindClass</code> function. If <code>FindClass</code> fails (returns <code>NULL</code>), the virtual machine must have thrown an exception (such as <code>NoClassDefFoundError</code>). In this case <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">JNU_ThrowByName</font> does not attempt to throw another exception. If <code>FindClass</code> succeeds, we throw the named exception by calling <code>ThrowNew</code>. When <code>JNU_ThrowByName</code> returns, it guarantees that there is a pending exception, although the pending exception was not necessarily what is specified by the <code>name</code> argument. We make sure to delete the local reference to the exception class created in this function. Passing <code>NULL</code> to <code>DeleteLocalRef</code> is a no-op, which is an appropriate action if <code>FindClass</code> fails and returns <code>NULL</code>. </font>
</p>

<a name="26074"></a>
<h2>6.2    Proper Exception Handling</h2>

<p>
  <a name="26373"> </a><font face="Arial, Verdana, Helvetica, sans-serif">JNI programmers must foresee possible exception conditions and write code that checks for and handles these cases. Proper exception handling is sometimes tedious but is necessary in order to produce robust applications.</font>
</p>

<a name="26379"></a>
<h3>6.2.1    Checking for Exceptions</h3>

<p>
  <a name="26445"> </a><font face="Arial, Verdana, Helvetica, sans-serif">There are two ways to check whether an error has occurred. </font>
</p>

<ol><font face="Arial, Verdana, Helvetica, sans-serif">
<li>Most JNI functions use a distinct return value (such as <code>NULL</code>) to indicate that an 
error has occurred. The error return value also implies that there is a pending 
exception in the current thread. (Encoding error conditions in the return value 
is common practice in C.)
</font>
<a name="32399"> </a><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">The following example illustrates using the <code>NULL</code> value returned by <code>Get-Field-ID</code> in checking for errors. The example consists of two parts: a class <code>Window</code> that defines a number of instance fields (<code>handle</code>, <code>length</code>, and <code>width</code>) and a native method that caches the field IDs of these fields. Even though these fields exist in the <code>Window</code> class, we still need to check for possible errors returned from <code>GetFieldID</code> because the virtual machine may not be able to allocate the memory needed to represent a field ID.<br></font>

<pre>
<a name="26447"> </a>/* a class in the Java programming language */
<a name="26448"> </a>public class Window {
<a name="29163"> </a>    long handle;
<a name="29169"> </a>    int length;
<a name="29170"> </a>    int width;
<a name="29164"> </a>    static native void initIDs();
<a name="29165"> </a>    static {
<a name="29166"> </a>        initIDs();
<a name="29167"> </a>    }
<a name="29168"> </a>}
<a name="26451"> </a>
<a name="26452"> </a>/* C code that implements Window.initIDs */
<a name="29184"> </a>jfieldID FID_Window_handle;
<a name="29186"> </a>jfieldID FID_Window_length;
<a name="29188"> </a>jfieldID FID_Window_width;
<a name="26455"> </a>
<a name="29189"> </a>JNIEXPORT void JNICALL
<a name="56789"> </a>Java_Window_initIDs(JNIEnv *env, jclass classWindow)
<a name="26456"> </a>{
<a name="26465"> </a>    FID_Window_handle =
<a name="29198"> </a>        (*env)-&gt;GetFieldID(env, classWindow, "handle", "J");
<a name="26466"> </a>    if (FID_Window_handle == NULL) { <code> /* important check. */
</code><a name="26467"> </a>        return; /* error occurred. */
<a name="26468"> </a>    }
<a name="29207"> </a>    FID_Window_length =
<a name="29208"> </a>        (*env)-&gt;GetFieldID(env, classWindow, "length", "I");
<a name="29209"> </a>    if (FID_Window_length == NULL) { <code> /* important check. */
</code><a name="29210"> </a>        return; /* error occurred. */
<a name="29211"> </a>    }
<a name="29213"> </a>    FID_Window_width =
<a name="29214"> </a>        (*env)-&gt;GetFieldID(env, classWindow, "width", "I");
<a name="29236"> </a>    /* no checks necessary; we are about to return anyway */
<a name="26470"> </a>}
</pre>

<p>
  <a name="26471"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>

<li><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</ol><pre>
<a name="26473"> </a>public class Fraction {
<a name="26474"> </a>    // details such as constructors omitted
<a name="26475"> </a>    int over, under;
<a name="26476"> </a>    public int floor() {
<a name="26477"> </a>        return Math.floor((double)over/under);
<a name="26478"> </a>    }
<a name="26479"> </a>}
<a name="53461"> </a>
<a name="53462"> </a>
<a name="53463"> </a>
<a name="53464"> </a>
<a name="53465"> </a>
<a name="53466"> </a>
<a name="46683"> </a>
<a name="26481"> </a>/* Native code that calls Fraction.floor. Assume method ID
<a name="29258"> </a>   MID_Fraction_floor has been initialized elsewhere. */
<a name="26483"> </a>void f(JNIEnv *env, jobject fraction)
<a name="29261"> </a>{
<a name="26484"> </a>    jint floor = (*env)-&gt;CallIntMethod(env, fraction,
<a name="29255"> </a>                                       MID_Fraction_floor);
<a name="26486"> </a>    /* important: check if an exception was raised */
<a name="26487"> </a>    if ((*env)-&gt;ExceptionCheck(env)) {
<a name="26488"> </a>        return;
<a name="26489"> </a>    }
<a name="26490"> </a>    ... /* use floor */
<a name="26491"> </a>}
</pre>

<p>
  <a name="26501"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When the JNI function returns a distinct error code, the native code may still check for exceptions explicitly by calling, for example, <code>ExceptionCheck</code>. However, it is more efficient to check for the distinct error return value instead. <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">If a JNI function returns its error value, a subsequent </font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">ExceptionCheck</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"> call in the current thread is guaranteed to return </font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">JNI_TRUE</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">.</font></font>
</p>

<a name="26383"></a>
<h3>6.2.2    Handling Exceptions</h3>

<p>
  <a name="26368"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Native code may handle a pending exception in two ways:</font>
</p>

<a name="26369"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>The native method implementation can choose to return immediately, causing the exception to be handled in the caller.</font><a name="26370"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>The native code can clear the exception by calling <code>ExceptionClear</code> and then execute its own exception handling code.</font>
</ul>
<p>
  <a name="4698"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">It is extremely important to check, handle, and clear a pending exception before calling any subsequent JNI functions</font>. Calling most JNI functions with a pending exception--with an exception that you have not explicitly cleared--may lead to unexpected results. You can call only a small number of JNI functions safely when there is a pending exception in the current thread. Section <a href="design.html#2193">11.8.2</a> specifies the complete list of these JNI functions. Generally speaking, when there is a pending exception you can call the JNI functions that are designed to handle exceptions and the JNI functions that release various virtual machine resources exposed through the JNI. </font>
</p>


<p>
  <a name="53440"> </a><font face="Arial, Verdana, Helvetica, sans-serif">It is often necessary to be able to free resources when exceptions occur. In the following example, the native method first obtains the contents of a string by issuing a <code>GetStringChars</code> call. It calls <code>ReleaseStringChars</code> if a subsequent operation fails:</font>
</p>


<p>
  <a name="53471"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="53472"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>

<pre>
<a name="26082"> </a>JNIEXPORT void JNICALL
<a name="56794"> </a>Java_pkg_Cls_f(JNIEnv *env, jclass cls, jstring jstr)
<a name="26087"> </a>{
<a name="26088"> </a>    const jchar *cstr = (*env)-&gt;GetStringChars(env, jstr);
<a name="26090"> </a>    if (c_str == NULL) {
<a name="26091"> </a>        return;
<a name="26092"> </a>    }
<a name="26093"> </a>    ...
<a name="26094"> </a>    if (...) { /* exception occurred */
<a name="26095"> </a>        (*env)-&gt;ReleaseStringChars(env, jstr, cstr);
<a name="26096"> </a>        return;
<a name="26097"> </a>    }
<a name="26098"> </a>    ...
<a name="26108"> </a>    /* normal return */
<a name="26099"> </a>    (*env)-&gt;ReleaseStringChars(env, jstr, cstr);
<a name="26109"> </a>}
</pre>

<p>
  <a name="26349"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The first call to <code>ReleaseStringChars</code> is issued when there is a pending exception. The native method implementation releases the string resource and returns immediately afterwards without first clearing the exception.</font>
</p>

<a name="26354"></a>
<h3>6.2.3    Exceptions in Utility Functions</h3>

<p>
  <a name="26350"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Programmers writing utility functions should pay special attention to ensure that exceptions are propagated to the caller native method. In particular, we emphasize the following two issues:</font>
</p>

<a name="26405"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Preferably, utility functions should provide a special return value to indicate that an exception has occurred. This simplifies the caller's task of checking for pending exceptions.</font><a name="26408"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>In addition, utility functions should follow the rules (<a href="refs.html#27623">&#167;5.3</a>) for managing local references in exception handling code.</font>
<p>
  <a name="26404"> </a><font face="Arial, Verdana, Helvetica, sans-serif">To illustrate, let us introduce a utility function that performs a callback based on the name and descriptor of an instance method:</font>
</p>

<pre>
<a name="53478"> </a>jvalue
<a name="26133"> </a>JNU_CallMethodByName(JNIEnv *env,
<a name="26210"> </a>                     jboolean *hasException,
<a name="26213"> </a>                     jobject obj, 
<a name="26136"> </a>                     const char *name,
<a name="26216"> </a>                     const char *descriptor, ...)
<a name="26139"> </a>{
<a name="26223"> </a>    va_list args;
<a name="26140"> </a>    jclass clazz;
<a name="26141"> </a>    jmethodID mid;
<a name="26142"> </a>    jvalue result;
<a name="26148"> </a>    if ((*env)-&gt;EnsureLocalCapacity(env, 2) == JNI_OK) {
<a name="26151"> </a>        clazz = (*env)-&gt;GetObjectClass(env, obj);
<a name="26152"> </a>        mid = (*env)-&gt;GetMethodID(env, clazz, name,
<a name="56797"> </a>                                  descriptor);
<a name="26153"> </a>        if (mid) {
<a name="26268"> </a>            const char *p = descriptor;
<a name="26270"> </a>            /* skip over argument types to find out the 
<a name="32476"> </a>               return type */
<a name="26271"> </a>            while (*p != ')') p++;
<a name="26272"> </a>            /* skip ')' */
<a name="26273"> </a>            p++;
<a name="26224"> </a>            va_start(args, descriptor);
<a name="26155"> </a>            switch (*p) {
<a name="26156"> </a>            case 'V':
<a name="26157"> </a>                (*env)-&gt;CallVoidMethodV(env, obj, mid, args);
<a name="26158"> </a>                break;
<a name="26159"> </a>            case '[':
<a name="26160"> </a>            case 'L':
<a name="26161"> </a>                result.l = (*env)-&gt;CallObjectMethodV(
<a name="26234"> </a>                                       env, obj, mid, args);
<a name="26162"> </a>                break;
<a name="26163"> </a>            case 'Z':
<a name="26164"> </a>                result.z = (*env)-&gt;CallBooleanMethodV(
<a name="26235"> </a>                                       env, obj, mid, args);
<a name="26165"> </a>                break;
<a name="26166"> </a>            case 'B':
<a name="26167"> </a>                result.b = (*env)-&gt;CallByteMethodV(
<a name="26236"> </a>                                       env, obj, mid, args);
<a name="26168"> </a>                break;
<a name="26169"> </a>            case 'C':
<a name="26170"> </a>                result.c = (*env)-&gt;CallCharMethodV(
<a name="26237"> </a>                                       env, obj, mid, args);
<a name="26171"> </a>                break;
<a name="26172"> </a>            case 'S':
<a name="26173"> </a>                result.s = (*env)-&gt;CallShortMethodV(
<a name="26238"> </a>                                       env, obj, mid, args);
<a name="26174"> </a>                break;
<a name="26175"> </a>            case 'I':
<a name="26176"> </a>                result.i = (*env)-&gt;CallIntMethodV(
<a name="26239"> </a>                                       env, obj, mid, args);
<a name="26177"> </a>                break;
<a name="26178"> </a>            case 'J':
<a name="26179"> </a>                result.j = (*env)-&gt;CallLongMethodV(
<a name="26240"> </a>                                       env, obj, mid, args);
<a name="26180"> </a>                break;
<a name="26181"> </a>            case 'F':
<a name="26182"> </a>                result.f = (*env)-&gt;CallFloatMethodV(
<a name="26241"> </a>                                       env, obj, mid, args);
<a name="26183"> </a>                break;
<a name="26184"> </a>            case 'D':
<a name="26185"> </a>                result.d = (*env)-&gt;CallDoubleMethodV(
<a name="26242"> </a>                                       env, obj, mid, args);
<a name="26186"> </a>                break;
<a name="26187"> </a>            default:
<a name="26188"> </a>                (*env)-&gt;FatalError(env, "illegal descriptor");
<a name="26189"> </a>            }
<a name="26225"> </a>            va_end(args);
<a name="26246"> </a>        }
<a name="26191"> </a>        (*env)-&gt;DeleteLocalRef(env, clazz);
<a name="26254"> </a>    }
<a name="26193"> </a>    if (hasException) {
<a name="26194"> </a>        *hasException = (*env)-&gt;ExceptionCheck(env);
<a name="26195"> </a>    }
<a name="26196"> </a>    return result;
<a name="26197"> </a>}
</pre>

<p>
  <a name="26276"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>JNU_CallMethodByName</code> takes, among other arguments, a pointer to a <code>jboolean</code>. The <code>jboolean</code> will be set to <code>JNI_FALSE</code> if everything succeeds and to <code>JNI_TRUE</code> if an exception occurs at any point during the execution of this function. This gives the caller of <code>JNU_CallMethodByName</code> an obvious way to check for possible exceptions.</font>
</p>


<p>
  <a name="26415"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>JNU_CallMethodByName</code> first makes sure that it can create two local references: one for the class reference and the other for the result returned from the method call. Next, it obtains the class reference from the object and looks up the method ID. Depending on the return type, the <code>switch</code> statement dispatches to the corresponding JNI method call function. After the callback returns, if <code>hasException</code> is not <code>NULL</code>, we call <code>ExceptionCheck</code> to check for pending exceptions.</font>
</p>


<p>
  <a name="26279"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The <code>ExceptionCheck</code> function is new in Java 2 SDK release 1.2. It is similar to the <code>ExceptionOccurred</code> function. The difference is that <code>ExceptionCheck</code> does not return a reference to the exception object, but returns <code>JNI_TRUE</code> when there is a pending exception and returns <code>JNI_FALSE</code> when there is no pending exception. <code>ExceptionCheck</code> simplifies local reference management when the native code only needs to know whether an exception has occurred but needs not obtain a reference to the exception object. The previous code would have to be rewritten as follows in JDK release 1.1:</font>
</p>

<pre>
<a name="26282"> </a>  if (hasException) {
<a name="26285"> </a>        jthrowable exc = (*env)-&gt;ExceptionOccurred(env);
<a name="26283"> </a>        *hasException = exc != NULL;
<a name="26286"> </a>        (*env)-&gt;DeleteLocalRef(env, exc);
<a name="26284"> </a>  }
</pre>

<p>
  <a name="26291"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The additional <code>DeleteLocalRef</code> call is necessary in order to delete the local reference to the exception object.</font>
</p>


<p>
  <a name="29326"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Using the <code>JNU_CallMethodByName</code> function we can rewrite the implementation of <code>Instance-MethodCall.nativeMethod</code> in Section <a href="fldmeth.html#26010">4.2</a> as follows:</font>
</p>

<pre>
<a name="29329"> </a>JNIEXPORT void JNICALL 
<a name="29330"> </a>Java_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj)
<a name="29331"> </a>{
<a name="29332"> </a>    printf("In C\n");
<a name="29338"> </a>    JNU_CallMethodByName(env, NULL, obj, "callback", "()V");
<a name="29339"> </a>}
</pre>

<p>
  <a name="29347"> </a><font face="Arial, Verdana, Helvetica, sans-serif">We need not check for exceptions after the <code>JNU_CallMethodByName</code> call because the native method returns immediately afterwards.</font>
</p>


<p>
  <a name="29327"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>



<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="refs.html">Prev</a> | <a href="invoke.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<p>
<font size="-1"><i><a href="copyright.html">Copyright</a> &#169 2002 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jni@java.sun.com">jni@java.sun.com</a>
</font>
</body></html>