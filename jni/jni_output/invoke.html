<html>
<head>
<title> The Invocation Interface</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="exceptions.html">Prev</a> | <a href="other.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<hr><br>
 
<div align="right">
<h1 align="left">
  <a name="11201"> </a><font color="#663300" face="Arial, Verdana, Helvetica, sans-serif">Chapter 7 chapter</font>
</h1>
</div>
<a name="11202"></a>
<h1>The Invocation Interface</h1>
<hr><p>

<p>
  <a name="28718"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="7" face="Arial, Verdana, Helvetica, sans-serif">T</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">his</font> chapter illustrates how you can embed a Java virtual machine in your native application. A Java virtual machine implementation is typically shipped as a native library. Native applications can link against this library and use the invocation interface to load the Java virtual machine. Indeed, the standard launcher command (<code>java</code>) in JDK or Java 2 SDK releases is no more than a simple C program linked with the Java virtual machine. The launcher parses the command line arguments, loads the virtual machine, and runs Java applications through the invocation interface.</font>
</p>

<a name="28719"></a>
<h2>7.1    Creating the Java Virtual Machine</h2>

<p>
  <a name="28720"> </a><font face="Arial, Verdana, Helvetica, sans-serif">To illustrate the invocation interface, let's look at a C program that loads a Java virtual machine and calls the <code>Prog.main</code> method defined as follows:</font>
</p>

<pre>
<a name="5601"> </a>public class Prog {
<a name="4871"> </a>    public static void main(String[] args) {
<a name="4872"> </a>         System.out.println("Hello World " + args[0]);
<a name="4873"> </a>    }
<a name="4874"> </a>}
</pre>

<p>
  <a name="4884"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The following C program, <code>invoke.c</code>, loads a Java virtual machine and invokes <code>Prog.main</code>. </font>
</p>


<p>
  <a name="46638"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46639"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46640"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46641"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46642"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46643"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46644"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46645"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="46646"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>

<pre>
<a name="10536"> </a>#include &lt;jni.h&gt;
<a name="28723"> </a>
<a name="28724"> </a>#define PATH_SEPARATOR ';' /* define it to be ':' on Solaris */
<a name="10540"> </a>#define USER_CLASSPATH "." /* where Prog.class is */
<a name="11045"> </a>
<a name="10541"> </a>main() {
<a name="10542"> </a>    JNIEnv *env;
<a name="10543"> </a>    JavaVM *jvm;
<a name="10545"> </a>    jint res;
<a name="10546"> </a>    jclass cls;
<a name="10547"> </a>    jmethodID mid;
<a name="10548"> </a>    jstring jstr;
<a name="10620"> </a>    jclass stringClass;
<a name="10549"> </a>    jobjectArray args;
<a name="53505"> </a>
<a name="10551"> </a>#ifdef JNI_VERSION_1_2
<a name="11773"> </a>    JavaVMInitArgs vm_args;
<a name="53514"> </a>    JavaVMOption options[1];
<a name="53516"> </a>    options[0].optionString =
<a name="11816"> </a>        "-Djava.class.path=" USER_CLASSPATH;
<a name="11785"> </a>    vm_args.version = 0x00010002;
<a name="11786"> </a>    vm_args.options = options;
<a name="11787"> </a>    vm_args.nOptions = 1;
<a name="11777"> </a>    vm_args.ignoreUnrecognized = JNI_TRUE;
<a name="36031"> </a>    /* Create the Java VM */
<a name="36032"> </a>    res = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args);
<a name="11778"> </a>#else
<a name="11770"> </a>    JDK1_1InitArgs vm_args;
<a name="28746"> </a>    char classpath[1024];
<a name="10608"> </a>    vm_args.version = 0x00010001;
<a name="10553"> </a>    JNI_GetDefaultJavaVMInitArgs(&amp;vm_args);
<a name="10554"> </a>    /* Append USER_CLASSPATH to the default system class path */
<a name="10555"> </a>    sprintf(classpath, "%s%c%s",
<a name="10556"> </a>            vm_args.classpath, PATH_SEPARATOR, USER_CLASSPATH);
<a name="10557"> </a>    vm_args.classpath = classpath;
<a name="36041"> </a>    /* Create the Java VM */
<a name="36042"> </a>    res = JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args);
<a name="11774"> </a>#endif /* JNI_VERSION_1_2 */
<a name="11775"> </a>
<a name="10790"> </a>    if (res &lt; 0) {
<a name="10791"> </a>        fprintf(stderr, "Can't create Java VM\n");
<a name="10792"> </a>        exit(1);
<a name="10793"> </a>    }
<a name="10564"> </a>    cls = (*env)-&gt;FindClass(env, "Prog");
<a name="10565"> </a>    if (cls == NULL) {
<a name="10568"> </a>        goto destroy;
<a name="10786"> </a>    }
<a name="53528"> </a>
<a name="47961"> </a>    mid = (*env)-&gt;GetStaticMethodID(env, cls, "main",
<a name="10611"> </a>                                    "([Ljava/lang/String;)V");
<a name="10571"> </a>    if (mid == NULL) {
<a name="10572"> </a>        goto destroy;
<a name="10574"> </a>    }
<a name="10575"> </a>    jstr = (*env)-&gt;NewStringUTF(env, " from C!");
<a name="10576"> </a>    if (jstr == NULL) {
<a name="10577"> </a>        goto destroy;
<a name="10579"> </a>    }
<a name="10621"> </a>    stringClass = (*env)-&gt;FindClass(env, "java/lang/String");
<a name="10580"> </a>    args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);
<a name="10582"> </a>    if (args == NULL) {
<a name="10583"> </a>        goto destroy;
<a name="10585"> </a>    }
<a name="10586"> </a>    (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args);
<a name="10769"> </a>
<a name="10775"> </a>destroy:
<a name="10770"> </a>    if ((*env)-&gt;ExceptionOccurred(env)) {
<a name="10771"> </a>        (*env)-&gt;ExceptionDescribe(env);
<a name="10772"> </a>    }
<a name="10587"> </a>    (*jvm)-&gt;DestroyJavaVM(jvm);
<a name="4935"> </a>}
</pre>

<p>
  <a name="53546"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The code conditionally compiles an initialization structure <code>JDK1_1InitArgs</code> that is specific to the virtual machine implementation in JDK release 1.1. Java 2 SDK release 1.2 still supports <code>JDK1_1InitArgs</code>, although it introduces a general-purpose virtual machine initialization structure called <code>JavaVMInitArgs</code>. The constant <code>JNI_VERSION_1_2</code> is defined in Java 2 SDK release 1.2, but not in JDK release 1.1.</font>
</p>


<p>
  <a name="10632"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When it targets the 1.1 release, the C code begins with a call to <code>JNI_GetDefaultJavaVMInitArgs</code> to obtain the default virtual machine settings. <code>JNI_GetDefaultJavaVMInitArgs</code> returns such values as the heap size, stack size, default class path, and so on, in the <code>vm_args</code> parameter. We then append the directory in which <code>Prog.class</code> resides to <code>vm_args.classpath</code>.</font>
</p>


<p>
  <a name="46630"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When it targets the 1.2 release, the C code creates a <code>JavaVMInitArgs</code> structure. The virtual machine initialization arguments are stored in a <code>JavaVMOption</code> array. You can set both common options (e.g., <code>-Djava.class.path=.</code>) and implementation-specific options (e.g., <code>-Xmx64m</code>) that directly correspond to <code>java</code> command line options. Setting <code>ignoreUnrecognized</code> field to <code>JNI_TRUE</code> instructs the virtual machine to ignore unrecognized implementation-specific options.</font>
</p>


<p>
  <a name="11062"> </a><font face="Arial, Verdana, Helvetica, sans-serif">After setting up the virtual machine initialization structure, the C program calls <code>JNI_CreateJavaVM</code> to load and initialize the Java virtual machine. The <code>JNI_CreateJavaVM</code> function fills in two return values:</font>
</p>

<a name="4940"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>An interface pointer, <code>jvm</code>, to the newly created Java virtual machine.</font><a name="4941"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>The <code>JNIEnv</code> interface pointer <code>env</code> for the current thread. Recall that native code accesses JNI functions through the <code>env</code> interface pointer.</font>
</ul>
<p>
  <a name="11066"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When the <code>JNI_CreateJavaVM</code> function returns successfully, the current native thread has bootstrapped itself into the Java virtual machine. At this point it is running just like a native method. Thus it can, among other things, issue JNI calls to invoke the <code>Prog.main</code> method. </font>
</p>


<p>
  <a name="4942"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Eventually the program calls the <code>DestroyJavaVM</code> function to unload the Java virtual machine. (Unfortunately, you cannot unload the Java virtual machine implementation in JDK release 1.1 or Java 2 SDK release 1.2. <code>DestroyJavaVM</code> always returns an error code in these releases.)</font>
</p>


<p>
  <a name="28725"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Running the above program produces:</font>
</p>

<pre>
<a name="28726"> </a>Hello World from C!
</pre>
<a name="4944"></a>
<h2>7.2    Linking Native Applications with the Java Virtual Machine</h2>

<p>
  <a name="4945"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The invocation interface requires you to link programs such as <code>invoke.c</code> with a Java virtual machine implementation. How you link with the Java virtual machine depends on whether the native application is intended to be deployed with only a particular virtual machine implementation or it is designed to work with a variety of virtual machine implementations from different vendors.</font>
</p>

<a name="28755"></a>
<h3>7.2.1    Linking with a Known Java Virtual Machine</h3>

<p>
  <a name="28753"> </a><font face="Arial, Verdana, Helvetica, sans-serif">You may decide that your native application will be deployed only with a particular virtual machine implementation. In this case you can link the native application with the native library that implements the virtual machine. For example, with the JDK 1.1 release for Solaris, you can use the following command to compile and link <code>invoke.c</code>:</font>
</p>

<pre>
<a name="4946"> </a>cc -I&lt;jni.h dir&gt; -L&lt;libjava.so dir&gt; -lthread -ljava invoke.c
</pre>

<p>
  <a name="4947"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The <code>-lthread</code> option indicates that we use the Java virtual machine implementation with native thread support (<a href="other.html#29406">&#167;8.1.5</a>). The <code>-ljava</code> option specifies that <code>libjava.so</code> is the Solaris shared library that implements the Java virtual machine.</font>
</p>


<p>
  <a name="56883"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56884"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56885"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="36144"> </a><font face="Arial, Verdana, Helvetica, sans-serif">On Win32 with the Microsoft Visual C++ compiler, the command line to compile and link the same program with JDK 1.1 release is:</font>
</p>

<pre>
<a name="4948"> </a>cl -I&lt;jni.h dir&gt; -MD invoke.c -link &lt;javai.lib dir&gt;\javai.lib
</pre>

<p>
  <a name="53557"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Of course, you need to supply the correct include and library directories that correspond to the JDK installation on your machine. The <code>-MD</code> option ensures that your native application is linked with the Win32 multithreaded C library, the same C library used by the Java virtual machine implementation in JDK 1.1 and Java 2 SDK 1.2 releases. The <code>cl</code> command consults the <code>javai.lib</code> file, shipped with JDK release 1.1 on Win32, for linkage information about invocation interface functions such as <code>JNI_CreateJavaVM</code> implemented in the virtual machine. The actual JDK 1.1 virtual machine implementation used at run time is contained in a separate dynamic link library file called <code>javai.dll</code>. In contrast, the same Solaris shared library (<code>.so</code> file) is used both at link time and at run time.</font>
</p>


<p>
  <a name="32001"> </a><font face="Arial, Verdana, Helvetica, sans-serif">With Java 2 SDK release 1.2, virtual machine library names have changed to <code>libjvm.so</code> on Solaris and to <code>jvm.lib</code> and <code>jvm.dll</code> on Win32. In general, different vendors may name their virtual machine implementations differently.</font>
</p>


<p>
  <a name="8485"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Once compilation and linking are complete you can run the resulting executable from the command line. You may get an error that the system cannot find either a shared library or a dynamic link library. On Solaris, if the error message indicates that the system cannot find the shared library <code>libjava.so</code> (or <code>libjvm.so</code> in Java 2 SDK release 1.2), then you need to add the directory containing the virtual machine library to your <code>LD_LIBRARY_PATH</code> variable. On a Win32 system, the error message may indicate that it cannot find the dynamic link library <code>javai.dll</code> (or <code>jvm.dll</code> in Java 2 SDK release 1.2). If this is the case, add the directory containing the DLL to your <code>PATH</code> environment variable. </font>
</p>

<a name="24891"></a>
<h3>7.2.2    Linking with Unknown Java Virtual Machines</h3>

<p>
  <a name="24892"> </a><font face="Arial, Verdana, Helvetica, sans-serif">You cannot link the native application with one specific library that implements a virtual machine if the application is intended to work with virtual machine implementations from different vendors. Because the JNI does not specify the name of the native library that implements a Java virtual machine, you should be prepared to work with Java virtual machine implementations that are shipped under different names. For example, on Win32 the virtual machine is shipped as <code>javai.dll</code> in JDK release 1.1 and as <code>jvm.dll</code> in Java 2 SDK release 1.2.</font>
</p>


<p>
  <a name="56886"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56887"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56888"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="24893"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The solution is to use run-time dynamic linking to load the particular virtual machine library needed by the application. The name of the virtual machine library can then be easily configured in an application-specific way. For example, the following Win32 code finds the function entry point for <code>JNI_CreateJavaVM</code> given the path of a virtual machine library:</font>
</p>

<pre>
<a name="24894"> </a>/* Win32 version */
<a name="28798"> </a>void *JNU_FindCreateJavaVM(char *vmlibpath)
<a name="24895"> </a>{
<a name="24896"> </a>    HINSTANCE hVM = LoadLibrary(vmlibpath);
<a name="24897"> </a>    if (hVM == NULL) {
<a name="24898"> </a>        return NULL;
<a name="24899"> </a>    }
<a name="24900"> </a>    return GetProcAddress(hVM, "JNI_CreateJavaVM");
<a name="24901"> </a>}
</pre>

<p>
  <a name="28797"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>LoadLibrary</code> and <code>GetProcAddress</code> are the API functions for dynamic linking on Win32. Although <code>LoadLibrary</code> can accept either the name (such as "<code>jvm</code>") or the path (such as "<code>C:\\jdk1.2\\jre\\bin\\classic\\jvm.dll</code>") of the native library that implements the Java virtual machine, it is preferable that you pass the absolute path of the native library to <code>JNU_FindCreateJavaVM</code>. Relying on <code>LoadLibrary</code> to search for <code>jvm.dll</code> makes your application susceptible to configuration changes, such as additions to the <code>PATH</code> environment variable.</font>
</p>


<p>
  <a name="36229"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The Solaris version is similar:</font>
</p>

<pre>
<a name="28789"> </a>/* Solaris version */
<a name="28799"> </a>void *JNU_FindCreateJavaVM(char *vmlibpath)
<a name="28790"> </a>{
<a name="28791"> </a>    void *libVM = dlopen(vmlibpath, RTLD_LAZY);
<a name="28792"> </a>    if (libVM == NULL) {
<a name="28793"> </a>        return NULL;
<a name="28794"> </a>    }
<a name="28795"> </a>    return dlsym(libVM, "JNI_CreateJavaVM");
<a name="28810"> </a>}
</pre>

<p>
  <a name="28814"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The <code>dlopen</code> and <code>dlsym</code> functions support dynamically linking shared libraries on Solaris.</font>
</p>


<p>
  <a name="56904"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56905"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56906"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>

<a name="9726"></a>
<h2>7.3    Attaching Native Threads</h2>

<p>
  <a name="53470"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Suppose that you have a multithreaded application such as a web server written in C. As HTTP requests come in, the server creates a number of native threads to handle the HTTP requests concurrently. We would like to embed a Java virtual machine in this server so that multiple threads can perform operations in the Java virtual machine at the same time, as illustrated in Figure <a href="invoke.html#41125">7.1</a>.</font>
</p>


<p>
  <a name="53498"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><img src="invokea.gif" height="257" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="41125"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 7.1	</b>&nbsp;&nbsp;Embedding the Java virtual machine in a web server</font><p>
<p>
  <a name="28854"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Server-spawned native methods may have a shorter life span than the Java virtual machine. Therefore, we need a way to attach a native thread to a Java virtual machine that is already running, perform JNI calls in the attached native thread, and then detach the native thread from the virtual machine without disrupting other attached threads.</font>
</p>


<p>
  <a name="28917"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The following example, <code>attach.c</code>, illustrates how to attach native threads to a virtual machine using the invocation interface. This program is written using the Win32 thread API. Similar versions can be written for Solaris and other operating systems. </font>
</p>


<p>
  <a name="56917"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56897"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56898"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56899"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56900"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>


<p>
  <a name="56901"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>

<pre>
<a name="10653"> </a>/* Note: This program only works on Win32 */
<a name="10655"> </a>#include &lt;windows.h&gt;
<a name="10656"> </a>#include &lt;jni.h&gt;
<a name="56920"> </a>JavaVM *jvm; /* The virtual machine instance */
<a name="56921"> </a>
<a name="56922"> </a>#define PATH_SEPARATOR ';'
<a name="11110"> </a>#define USER_CLASSPATH "." /* where Prog.class is */
<a name="11135"> </a>
<a name="11136"> </a>void thread_fun(void *arg)
<a name="10659"> </a>{
<a name="10660"> </a>    jint res;
<a name="10661"> </a>    jclass cls;
<a name="10662"> </a>    jmethodID mid;
<a name="10663"> </a>    jstring jstr;
<a name="10757"> </a>    jclass stringClass;
<a name="10664"> </a>    jobjectArray args;
<a name="10665"> </a>    JNIEnv *env;
<a name="10666"> </a>    char buf[100];
<a name="10667"> </a>    int threadNum = (int)arg;
<a name="10668"> </a>    /* Pass NULL as the third argument */
<a name="36078"> </a>#ifdef JNI_VERSION_1_2
<a name="36079"> </a>    res = (*jvm)-&gt;AttachCurrentThread(jvm, (void**)&amp;env, NULL);
<a name="36080"> </a>#else
<a name="36081"> </a>    res = (*jvm)-&gt;AttachCurrentThread(jvm, &amp;env, NULL);
<a name="10669"> </a>#endif
<a name="10670"> </a>    if (res &lt; 0) {
<a name="10671"> </a>       fprintf(stderr, "Attach failed\n");
<a name="10672"> </a>       return;
<a name="10673"> </a>    }
<a name="10674"> </a>    cls = (*env)-&gt;FindClass(env, "Prog");
<a name="10675"> </a>    if (cls == NULL) {
<a name="10677"> </a>        goto detach;
<a name="10678"> </a>    }
<a name="10679"> </a>    mid = (*env)-&gt;GetStaticMethodID(env, cls, "main", 
<a name="10750"> </a>                                    "([Ljava/lang/String;)V");
<a name="10680"> </a>    if (mid == NULL) {
<a name="10682"> </a>        goto detach;
<a name="10683"> </a>    }
<a name="10684"> </a>    sprintf(buf, " from Thread %d", threadNum);
<a name="10685"> </a>    jstr = (*env)-&gt;NewStringUTF(env, buf);
<a name="10686"> </a>    if (jstr == NULL) {
<a name="10688"> </a>        goto detach;
<a name="10689"> </a>    }
<a name="10690"> </a>    stringClass = (*env)-&gt;FindClass(env, "java/lang/String");
<a name="10696"> </a>    args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr);
<a name="10698"> </a>    if (args == NULL) {
<a name="10700"> </a>        goto detach;
<a name="10701"> </a>    }
<a name="10702"> </a>    (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args);
<a name="10810"> </a>
<a name="10703"> </a> detach:
<a name="10704"> </a>    if ((*env)-&gt;ExceptionOccurred(env)) {
<a name="10705"> </a>        (*env)-&gt;ExceptionDescribe(env);
<a name="10706"> </a>    }
<a name="10707"> </a>    (*jvm)-&gt;DetachCurrentThread(jvm);
<a name="36096"> </a>}
<a name="36097"> </a>
<a name="36100"> </a>main() {
<a name="36101"> </a>    JNIEnv *env;
<a name="36102"> </a>    int i;
<a name="36103"> </a>    jint res;
<a name="36104"> </a>
<a name="36105"> </a>#ifdef JNI_VERSION_1_2
<a name="36106"> </a>    JavaVMInitArgs vm_args;
<a name="36107"> </a>    JavaVMOption options[1];
<a name="36108"> </a>    options[0].optionString =
<a name="36109"> </a>        "-Djava.class.path=" USER_CLASSPATH;
<a name="36110"> </a>    vm_args.version = 0x00010002;
<a name="36111"> </a>    vm_args.options = options;
<a name="36112"> </a>    vm_args.nOptions = 1;
<a name="36113"> </a>    vm_args.ignoreUnrecognized = TRUE;
<a name="36114"> </a>    /* Create the Java VM */
<a name="36115"> </a>    res = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args);
<a name="36116"> </a>#else
<a name="36117"> </a>    JDK1_1InitArgs vm_args;
<a name="36118"> </a>    char classpath[1024];
<a name="36119"> </a>    vm_args.version = 0x00010001;
<a name="36120"> </a>    JNI_GetDefaultJavaVMInitArgs(&amp;vm_args);
<a name="36121"> </a>    /* Append USER_CLASSPATH to the default system class path */
<a name="36122"> </a>    sprintf(classpath, "%s%c%s",
<a name="36123"> </a>            vm_args.classpath, PATH_SEPARATOR, USER_CLASSPATH);
<a name="36124"> </a>    vm_args.classpath = classpath;
<a name="36125"> </a>    /* Create the Java VM */
<a name="36126"> </a>    res = JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args);
<a name="36127"> </a>#endif /* JNI_VERSION_1_2 */
<a name="53529"> </a>
<a name="36128"> </a>if (res &lt; 0) {
<a name="36129"> </a>        fprintf(stderr, "Can't create Java VM\n");
<a name="36130"> </a>        exit(1);
<a name="36131"> </a>    }
<a name="36132"> </a>    for (i = 0; i &lt; 5; i++)
<a name="36133"> </a>        /* We pass the thread number to every thread */
<a name="36134"> </a>        _beginthread(thread_fun, 0, (void *)i);
<a name="36135"> </a>    Sleep(1000); /* wait for threads to start */
<a name="36136"> </a>    (*jvm)-&gt;DestroyJavaVM(jvm);
<a name="6048"> </a>}
</pre>

<p>
  <a name="5042"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The <code>attach.c</code> program is a variation of <code>invoke.c</code>. Rather than calling <code>Prog.main</code> in the main thread, the native code starts five threads. Once it has spawned the threads it waits for them to start and then calls <code>DestroyJavaVM</code>. Each spawned thread attaches itself to the Java virtual machine, invokes the <code>Prog.main</code> method, and finally detaches itself from the virtual machine before it terminates. <code>DestroyJavaVM</code> returns after all five threads terminate. We ignore the return value of <code>DestroyJavaVM</code> for now because this function is not fully implemented in JDK release 1.1 and Java 2 SDK release 1.2.</font>
</p>


<p>
  <a name="8606"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><code>JNI_AttachCurrentThread</code> takes <code>NULL</code> as its third argument. Java 2 SDK release 1.2 introduces the <code>JNI_ThreadAttachArgs</code> structure. It allows you to specify additional arguments, such as the thread group to which you would like to attach. The details of the <code>JNI_ThreadAttachArgs</code> structure is described as part of the specification for <code>JNI_AttachCurrentThread</code> in Section <a href="functions.html#70415">13.2</a>.</font>
</p>


<p>
  <a name="5043"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When the program executes the function <code>DetachCurrentThread</code> it frees all local references belonging to the current thread.</font>
</p>


<p>
  <a name="8607"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Running the program produces the following output:</font>
</p>

<pre>
<a name="8622"> </a>Hello World from thread 1
<a name="8624"> </a>Hello World from thread 0
<a name="8626"> </a>Hello World from thread 4
<a name="8628"> </a>Hello World from thread 2
<a name="8630"> </a>Hello World from thread 3
</pre>

<p>
  <a name="8618"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The exact order of output will likely vary depending on random factors in thread scheduling.</font>
</p>



<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="exceptions.html">Prev</a> | <a href="other.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<p>
<font size="-1"><i><a href="copyright.html">Copyright</a> &#169 2002 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jni@java.sun.com">jni@java.sun.com</a>
</font>
</body></html>