<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="part1.html">Prev</a> | <a href="start.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<hr><br>
 
<div align="right">
<h1 align="left">
  <a name="768"> </a><font color="#663300" face="Arial, Verdana, Helvetica, sans-serif">Chapter 1</font> 
</h1>
</div>
<div align="right">
<h1 align="left">
  <a name="875"> </a><font size="+5;" color="#663300" face="Arial, Verdana, Helvetica, sans-serif">Introduction </font>
</h1>
</div>



<p>
  <a name="876"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><font  size="7" face="Arial, Verdana, Helvetica, sans-serif">T</font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif">he</font> Java<font size="-1"><sup>TM</sup></font> Native Interface (JNI) is a powerful feature of the Java platform. Applications that use the JNI can incorporate <em>native code</em> written in programming languages such as C and C++, as well as code written in the Java programming language. The JNI allows programmers to take advantage of the power of the Java platform, without having to abandon their investments in legacy code. Because the JNI is a part of the Java platform, programmers can address interoperability issues once, and expect their solution to work with all implementations of the Java platform.</font>
</p>


<p>
  <a name="1276"> </a><font face="Arial, Verdana, Helvetica, sans-serif">This book is both a programming guide and a reference manual for the JNI. The book consists of three parts:</font>
</p>

<a name="1051"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Chapter <a href="start.html#768">2</a> introduces the JNI through a simple example. It is a tutorial intended for the beginning users who are unfamiliar with the JNI.</font><a name="1052"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Chapters <a href="objtypes.html#11201">3</a> to <a href="pitfalls.html#25705">10</a> constitute a programmer's guide that gives a broad overview of a number of JNI features. We will go though a series of short but descriptive examples to highlight various JNI features and to present the techniques that have proven to be useful in JNI programming.</font><a name="6574"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Chapters <a href="design.html#8147">11</a> to <a href="/home/pelouch/jni/fm/functions.html#29542">13</a> present the definitive specification for all JNI types and functions. These chapters are also organized to serve as a reference manual.</font>
</ul>
<p>
  <a name="1057"> </a><font face="Arial, Verdana, Helvetica, sans-serif">This book tries to appeal to a wide audience with different needs for the JNI. The tutorial and programming guide are targeted toward beginning programmers, whereas experienced developers and JNI implementors may find the reference sections more useful. The majority of readers will likely be developers who use the JNI to write applications. The term "you" in this book will implicitly denote developers who program with the JNI, as opposed to JNI implementors or end-users of applications written using the JNI.</font>
</p>


<p>
  <a name="1323"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The book assumes that you have basic knowledge of the Java, C, and C++ programming languages. If not, you may refer to one of the many excellent books that are available: <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">The Java</font><font size="-1"><sup>TM</sup></font><font  size="2" face="Arial, Verdana, Helvetica, sans-serif"> Programming Language, Second Edition</font>, by Ken Arnold and James Gosling (Addison-Wesley, 1998), <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">The C Programming Language, Second Edition</font>, by Brian Kernighan and Dennis Ritchie (Prentice Hall, 1988), and <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">The C++ Programming Language, Third Edition</font>, by Bjarne Stroustrup (Addison-Wesley, 1997).</font>
</p>


<p>
  <a name="1366"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The remainder of this chapter introduces the background, role, and evolution of the JNI.</font>
</p>

<a name="994"></a>
<h2>1.1    The Java Platform and Host Environment</h2>

<p>
  <a name="995"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Because this book covers applications written in the Java programming language as well as in native (C, C++, etc.) programming languages, let us first clarify the exact scope of the programming environments for these languages.</font>
</p>


<p>
  <a name="49975"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The Java platform is a programming environment consisting of the Java virtual machine (VM) and the Java Application Programming Interface (API).<font  size="3" face="Arial, Verdana, Helvetica, sans-serif"><a href="#50655"><sup>1</sup></a></font> Java applications are written in the Java programming language, and compiled into a machine-independent binary class format. A class can be executed on any Java virtual machine implementation. The Java API consists of a set of predefined classes. Any implementation of the Java platform is guaranteed to support the Java programming language, virtual machine, and API.</font>
</p>


<p>
  <a name="1515"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The term <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">host environment </font>represents the host operating system, a set of native libraries, and the CPU instruction set. <em>Native applications</em> are written in <em>native programming languages</em> such as C and C++, compiled into host-specific binary code, and linked with native libraries. Native applications and native libraries are typically dependent on a particular host environment. A C application built for one operating system, for example, typically does not work on other operating systems.</font>
</p>


<p>
  <a name="1618"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Java platforms are commonly deployed on top of a host environment. For example, the Java Runtime Environment (JRE) is a Sun product that supports the Java platform on existing operating systems such as Solaris and Windows. The Java platform offers a set of features that applications can rely on independent of the underlying host environment.</font>
</p>

<a name="1811"></a>
<h2>1.2    Role of the JNI</h2>

<p>
  <a name="4735"> </a><font face="Arial, Verdana, Helvetica, sans-serif">When the Java platform is deployed on top of host environments, it may become desirable or necessary to allow Java applications to work closely with native code written in other languages. Programmers have begun to adopt the Java platform to build applications that were traditionally written in C and C++. Because of the existing investment in legacy code, however, Java applications will coexist with C and C++ code for many years to come.</font>
</p>


<p>
  <a name="1654"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI is a powerful feature that allows you to take advantage of the Java platform, but still utilize code written in other languages. As a part of the Java virtual machine implementation, the JNI is a <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">two-way</font> interface that allows Java applications to invoke native code and vice versa. Figure <a href="intro.html#2922">1.1</a> illustrates the role of the JNI.<img src="introa.gif" height="236" width="500" align="center" border="0" hspace="0" vspace="0">
</font>
</p>

<a name="2922"> </a><font face="Arial, Verdana, Helvetica, sans-serif"><b>Figure 1.1	</b>&nbsp;&nbsp;Role of the JNI</font><p>
<p>
  <a name="6801"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI is designed to handle situations where you need to combine Java applications with native code. As a two-way interface, the JNI can support two types of native code: native <em>libraries</em> and native <em>applications</em>.</font>
</p>

<a name="6802"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>You can use the JNI to write <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">native methods</font> that allow Java applications to call functions implemented in native libraries. Java applications call native methods in the same way that they call methods implemented in the Java programming language. Behind the scenes, however, native methods are implemented in another language and reside in native libraries.</font><a name="6803"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>The JNI supports an <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">invocation interface</font> that allows you to embed a Java virtual machine implementation into native applications. Native applications can link with a native library that implements the Java virtual machine, and then use the invocation interface to execute software components written in the Java programming language. For example, a web browser written in C can execute downloaded applets in an embedded Java virtual machine implemention.</font>
</ul><a name="6942"></a>
<h2>1.3    Implications of Using the JNI</h2>

<p>
  <a name="6943"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Remember that once an application uses the JNI, it risks losing two benefits of the Java platform.</font>
</p>


<p>
  <a name="6944"> </a><font face="Arial, Verdana, Helvetica, sans-serif">First, Java applications that depend on the JNI can no longer readily run on multiple host environments. Even though the part of an application written in the Java programming language is portable to multiple host environments, it will be necessary to recompile the part of the application written in native programming languages.</font>
</p>


<p>
  <a name="6945"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Second, while the Java programming language is type-safe and secure, native languages such as C or C++ are not. As a result, you must use extra care when writing applications using the JNI. A misbehaving native method can corrupt the entire application. For this reason Java applications are subject to security checks before invoking JNI features.</font>
</p>


<p>
  <a name="6946"> </a><font face="Arial, Verdana, Helvetica, sans-serif">As a general rule, you should architect the application so that native methods are defined in as few classes as possible. This entails a cleaner isolation between native code and the rest of the application.</font>
</p>

<a name="6922"></a>
<h2>1.4    When to Use the JNI</h2>

<p>
  <a name="6923"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Before you embark on a project using the JNI, it is worth taking a step back to investigate whether there are alternative solutions that are more appropriate. As mentioned in the last section, applications that use the JNI have inherent disadvantages when compared with applications written strictly in the Java programming language. For example, you lose the type-safety guarantee of the Java programming language.</font>
</p>


<p>
  <a name="6924"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A number of alternative approaches also allow Java applications to interoperate with code written in other languages. For example:</font>
</p>

<a name="6925"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>A Java application may communicate with a native application through a TCP/IP connection or through other inter-process communication (IPC) mechanisms.</font><a name="6926"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>A Java application may connect to a legacy database through the JDBC<font size="-1"><sup>TM</sup></font> API.</font><a name="6927"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>A Java application may take advantage of distributed object technologies such as the Java IDL API.</font>
</ul>
<p>
  <a name="6928"> </a><font face="Arial, Verdana, Helvetica, sans-serif">A common characteristic of these alternative solutions is that the Java application and native code reside in different processes (and in some cases on different machines). Process separation offers an important benefit. The address space protection supported by processes enables a high degree of fault isolation--a crashed native application does not immediately terminate the Java application with which it communicates over TCP/IP.</font>
</p>


<p>
  <a name="6929"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Sometimes, however, you may find it necessary for a Java application to communicate with native code <font  size="2" face="Arial, Verdana, Helvetica, sans-serif">that resides in the same process</font>. This is when the JNI becomes useful. Consider, for example, the following scenarios:</font>
</p>

<a name="6930"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>The Java API might not support certain host-dependent features needed by an application. An application may want to perform, for example, special file operations that are not supported by the Java API, yet it is both cumbersome and inefficient to manipulate files through another process.</font><a name="6931"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>You may want to access an existing native library and are not willing to pay for the overhead of copying and transmitting data across different processes. Loading the native library in the same process is much more efficient.</font><a name="6932"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Having an application span multiple processes could result in unacceptable memory footprint. This is typically true if these processes need to reside on the same client machine. Loading a native library into the existing process hosting the application requires less system resources than starting a new process and loading the library into that process.</font><a name="6933"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>You may want to implement a small portion of time-critical code in a lower-level language, such as assembly. If a 3D-intensive application spends most of its time in graphics rendering, you may find it necessary to write the core portion of a graphics library in assembly code to achieve maximum performance. </font>
</ul>
<p>
  <a name="6934"> </a><font face="Arial, Verdana, Helvetica, sans-serif">In summary, use the JNI if your Java application must interoperate with native code that resides in the same process.</font>
</p>

<a name="2186"></a>
<h2>1.5    Evolution of the JNI</h2>

<p>
  <a name="42149"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The need for Java applications to interoperate with native code has been recognized since the very early days of the Java platform. The first release of the Java platform, Java Development Kit (JDK<font size="-1"><sup>TM</sup></font>) release 1.0, included a native method interface that allowed Java applications to call functions written in other languages such as C and C++. Many third-party applications, as well as the implementation of the Java class libraries (including, for example, <code>java.lang</code>, <code>java.io</code>, and <code>java.net</code>), relied on the native method interface to access the features in the underlying host environment.</font>
</p>


<p>
  <a name="42155"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Unfortunately, the native method interface in JDK release 1.0 had two major problems:</font>
</p>

<a name="2600"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>First, the native code accesses fields in objects as members of C structures. However, the Java virtual machine specification does not define how objects are laid out in memory. If a given Java virtual machine implementation lays out objects in a way other than that assumed by the native method interface, then you have to recompile the native method libraries. </font><a name="8476"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Second, the native method interface in JDK release 1.0 relies on a conservative garbage collector because native methods can get hold of direct pointers to objects in the virtual machine. Any virtual machine implementation that uses more advanced garbage collection algorithms cannot support the native method interface in JDK release 1.0.</font>
</ul>
<p>
  <a name="29695"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI was designed to overcome these problems. It is an interface that can be supported by all Java virtual machine implementations on a wide variety of host environments. With the JNI:</font>
</p>

<a name="29697"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><ul>
<li>Each virtual machine implementor can support a larger body of native code.</font><a name="2223"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Development tool vendors do not have to deal with different kinds of native method interfaces. </font><a name="2224"> </a>
<font face="Arial, Verdana, Helvetica, sans-serif"><li>Most importantly, application programmers are able to write one version of their native code and this version will run on different implementations of the Java virtual machine.</font>
</ul>
<p>
  <a name="2410"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI was first supported in JDK release 1.1. Internally, however, JDK release 1.1 still uses old-style native methods (as in JDK release 1.0) to implement the Java APIs. This is no longer the case in Java 2 SDK release 1.2 (formerly known as JDK release 1.2). Native methods have been rewritten so that they conform to the JNI standard.</font>
</p>


<p>
  <a name="2444"> </a><font face="Arial, Verdana, Helvetica, sans-serif">The JNI is the native interface supported by all Java virtual machine implementations. From JDK release 1.1 on, you should program to the JNI. The old-style native method interface is still supported in Java 2 SDK release 1.2, but will not (and cannot) be supported in advanced Java virtual machine implementations in the future.</font>
</p>


<p>
  <a name="2445"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Java 2 SDK release 1.2 contains a number of JNI enhancements. The enhancements are backward compatible. All future evolutions of JNI will maintain complete binary compatibility.</font>
</p>

<a name="10787"></a>
<h2>1.6    Example Programs</h2>

<p>
  <a name="10788"> </a><font face="Arial, Verdana, Helvetica, sans-serif">This book contains numerous example programs that demonstrate JNI features. The example programs typically consist of multiple code segments written in the Java programming language as well as C or C++ native code. Sometimes the native code refers to host-specific features in Solaris and Win32. We also show how to build JNI programs using the command line tools (such as <code>javah</code>) shipped with JDK and Java 2 SDK releases.</font>
</p>


<p>
  <a name="10933"> </a><font face="Arial, Verdana, Helvetica, sans-serif">Keep in mind that the use of the JNI is not limited to specific host environments or specific application development tools. The book focuses on writing the code, not on the tools used to build and run the code. The command line tools bundled with JDK and Java 2 SDK releases are rather primitive. Third-party tools may offer an improved way to build applications that use the JNI. We encourage you to consult the JNI-related documentation bundled with the development tools of your choice.</font>
</p>


<p>
  <a name="10813"> </a><font face="Arial, Verdana, Helvetica, sans-serif">You can download the source code of the examples in this book, as well as the latest updates to this book, from the following web address:</font>
</p>

<pre>
<a name="11253"> </a>http://java.sun.com/docs/books/jni/
</pre>

<p>
  <a name="11255"> </a><font face="Arial, Verdana, Helvetica, sans-serif"></font>
</p>



<hr>

<a name="50655"> </a><font face="Arial, Verdana, Helvetica, sans-serif" size="-1"><a href="#49975"><sup>1</sup></a>
<a name="50655"> </a><font face="Arial, Verdana, Helvetica, sans-serif" size="-1">As used herein, the phrases "Java virtual machine" or "Java VM" mean a virtual machine for the Java platform. Similarly, the phrase "Java API" means the API for the Java platform.</font></p>

</font></p>

<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="bookTOC.html;">Contents</a> | <a href="part1.html">Prev</a> | <a href="start.html">Next</a> | <a href="bookIX.html">Index</a></td>
<td align=right><i>The Java Native Interface<br>
Programmer's Guide and Specification</i>
</td></tr></table>
<p>
<font size="-1"><i><a href="copyright.html">Copyright</a> &#169 2002 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jni@java.sun.com">jni@java.sun.com</a>
</font>
</body></html>
